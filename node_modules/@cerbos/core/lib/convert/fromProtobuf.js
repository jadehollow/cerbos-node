"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.planResourcesResponseFromProtobuf = exports.checkResourcesResponseFromProtobuf = void 0;
const effect_1 = require("../protobuf/cerbos/effect/v1/effect");
const engine_1 = require("../protobuf/cerbos/engine/v1/engine");
const schema_1 = require("../protobuf/cerbos/schema/v1/schema");
const types_1 = require("../types");
const checkResourcesResponseFromProtobuf = ({ requestId, results, }) => new types_1.CheckResourcesResponse({
    requestId,
    results: results.map(checkResourcesResultFromProtobuf),
});
exports.checkResourcesResponseFromProtobuf = checkResourcesResponseFromProtobuf;
const checkResourcesResultFromProtobuf = ({ resource, actions, validationErrors, meta, }) => {
    if (!resource) {
        throw new Error("Missing resource on CheckResources result");
    }
    return new types_1.CheckResourcesResult({
        resource,
        actions: actionsFromProtobuf(actions),
        validationErrors: validationErrors.map(validationErrorFromProtobuf),
        metadata: meta,
    });
};
const actionsFromProtobuf = (actions) => Object.fromEntries(Object.entries(actions).map(([action, effect]) => [
    action,
    effectFromProtobuf(effect),
]));
const effectFromProtobuf = (effect) => effect === effect_1.Effect.EFFECT_ALLOW ? types_1.Effect.ALLOW : types_1.Effect.DENY;
const validationErrorFromProtobuf = ({ path, message, source, }) => ({
    path,
    message,
    source: validationErrorSourceFromProtobuf(source),
});
const validationErrorSourceFromProtobuf = (source) => {
    switch (source) {
        case schema_1.ValidationError_Source.SOURCE_PRINCIPAL:
            return types_1.ValidationErrorSource.PRINCIPAL;
        case schema_1.ValidationError_Source.SOURCE_RESOURCE:
            return types_1.ValidationErrorSource.RESOURCE;
        default:
            throw new Error(`Unexpected validation error source ${source} (${schema_1.ValidationError_Source[source] ?? "unrecognized"})`);
    }
};
const planResourcesResponseFromProtobuf = ({ requestId, filter, validationErrors, meta, }) => {
    if (!filter) {
        throw new Error("Missing filter on PlanResources response");
    }
    const kind = planKindFromProtobuf(filter.kind);
    const metadata = meta && planResourcesMetadataFromProtobuf(meta);
    if (kind === types_1.PlanKind.CONDITIONAL) {
        if (!filter.condition) {
            throw new Error("Missing filter condition on PlanResources response");
        }
        return {
            requestId,
            kind,
            condition: planOperandFromProtobuf(filter.condition),
            validationErrors: validationErrors.map(validationErrorFromProtobuf),
            metadata,
        };
    }
    return {
        requestId,
        kind,
        validationErrors: validationErrors.map(validationErrorFromProtobuf),
        metadata,
    };
};
exports.planResourcesResponseFromProtobuf = planResourcesResponseFromProtobuf;
const planKindFromProtobuf = (kind) => {
    switch (kind) {
        case engine_1.PlanResourcesFilter_Kind.KIND_ALWAYS_ALLOWED:
            return types_1.PlanKind.ALWAYS_ALLOWED;
        case engine_1.PlanResourcesFilter_Kind.KIND_ALWAYS_DENIED:
            return types_1.PlanKind.ALWAYS_DENIED;
        case engine_1.PlanResourcesFilter_Kind.KIND_CONDITIONAL:
            return types_1.PlanKind.CONDITIONAL;
        default:
            throw new Error(`Unexpected PlanResources filter kind ${kind} (${engine_1.PlanResourcesFilter_Kind[kind] ?? "unrecognized"})`);
    }
};
const planOperandFromProtobuf = ({ node, }) => {
    if (!node) {
        throw new Error("Missing node on PlanResources expression operand");
    }
    switch (node.$case) {
        case "expression":
            return new types_1.PlanExpression(node.expression.operator, node.expression.operands.map(planOperandFromProtobuf));
        case "value":
            return new types_1.PlanExpressionValue((node.value ?? null));
        case "variable":
            return new types_1.PlanExpressionVariable(node.variable);
    }
};
const planResourcesMetadataFromProtobuf = ({ filterDebug, matchedScope, }) => ({
    conditionString: filterDebug,
    matchedScope,
});
//# sourceMappingURL=fromProtobuf.js.map