"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ValidationErrorSource = exports.PlanKind = exports.PlanExpressionVariable = exports.PlanExpressionValue = exports.PlanExpression = exports.Effect = exports.CheckResourcesResult = exports.CheckResourcesResponse = void 0;
/**
 * The outcome of checking a principal's permissions on a set of resources.
 *
 * @public
 */
class CheckResourcesResponse {
    constructor({ requestId, results, }) {
        this.requestId = requestId;
        this.results = results;
    }
    /**
     * Check if the policy decision was that all input actions should be allowed for a resource.
     *
     * @param resource - the resource search criteria.
     * @returns `undefined` if the resource is not present in the results.
     */
    allAllowed(resource) {
        return this.findResult(resource)?.allAllowed();
    }
    /**
     * List the actions that should be allowed for a resource.
     *
     * @param resource - the resource search criteria.
     * @returns `undefined` if the resource is not present in the results.
     */
    allowedActions(resource) {
        return this.findResult(resource)?.allowedActions();
    }
    /**
     * Check if the policy decision was that an action should be allowed for a resource.
     *
     * @param check - the resource search criteria and action to check.
     * @returns `undefined` if the resource or action is not present in the results.
     */
    isAllowed(check) {
        return this.findResult(check.resource)?.isAllowed(check.action);
    }
    /**
     * Find an item from {@link CheckResourcesResponse.results | results} by resource.
     *
     * @param resource - the resource search criteria.
     * @returns `undefined` if the resource is not present in the results.
     */
    findResult(resource) {
        const { kind, id, policyVersion, scope } = resource;
        return this.results.find(({ resource }) => resource.kind === kind &&
            resource.id === id &&
            (policyVersion === undefined ||
                resource.policyVersion === policyVersion) &&
            (scope === undefined || resource.scope === scope));
    }
    /**
     * Unique schema validation errors for the principal or resource attributes.
     */
    get validationErrors() {
        const unique = {};
        this.results.forEach(({ validationErrors }) => {
            validationErrors.forEach((validationError) => {
                const { path, message, source } = validationError;
                unique[`${path}:${message}:${source}`] = validationError;
            });
        });
        return Object.values(unique);
    }
}
exports.CheckResourcesResponse = CheckResourcesResponse;
/**
 * The outcome of checking a principal's permissions on single resource.
 *
 * @public
 */
class CheckResourcesResult {
    constructor({ resource, actions, validationErrors, metadata, }) {
        this.resource = resource;
        this.actions = actions;
        this.validationErrors = validationErrors;
        this.metadata = metadata;
    }
    /**
     * Check if the policy decision was that all input actions should be allowed for the resource.
     */
    allAllowed() {
        return Object.values(this.actions).every((effect) => effect === Effect.ALLOW);
    }
    /**
     * List the actions that should be allowed for the resource.
     */
    allowedActions() {
        return Object.keys(this.actions).filter((action) => this.actions[action] === Effect.ALLOW);
    }
    /**
     * Check if the policy decision was that a given action should be allowed for the resource.
     *
     * @param action - the action to check.
     * @returns `undefined` if the action is not present in the results.
     */
    isAllowed(action) {
        switch (this.actions[action]) {
            case Effect.ALLOW:
                return true;
            case Effect.DENY:
                return false;
            default:
                return undefined;
        }
    }
}
exports.CheckResourcesResult = CheckResourcesResult;
/**
 * Outcomes of policy decisions.
 *
 * @public
 */
var Effect;
(function (Effect) {
    /**
     * The action should be allowed.
     */
    Effect["ALLOW"] = "EFFECT_ALLOW";
    /**
     * The action should be denied.
     */
    Effect["DENY"] = "EFFECT_DENY";
})(Effect = exports.Effect || (exports.Effect = {}));
/**
 * An abstract syntax tree node representing an expression to evaluate.
 *
 * @public
 */
class PlanExpression {
    constructor(
    /**
     * The operator to invoke.
     */
    operator, 
    /**
     * The operands on which to invoke the operator.
     */
    operands) {
        this.operator = operator;
        this.operands = operands;
    }
}
exports.PlanExpression = PlanExpression;
/**
 * An abstract syntax tree node representing a constant value.
 *
 * @public
 */
class PlanExpressionValue {
    constructor(
    /**
     * The constant value.
     */
    value) {
        this.value = value;
    }
}
exports.PlanExpressionValue = PlanExpressionValue;
/**
 * An abstract syntax tree node representing a variable whose value was unknown when producing the query plan.
 *
 * @public
 */
class PlanExpressionVariable {
    constructor(
    /**
     * The name of the variable.
     */
    name) {
        this.name = name;
    }
}
exports.PlanExpressionVariable = PlanExpressionVariable;
/**
 * Types of query plans.
 *
 * @public
 */
var PlanKind;
(function (PlanKind) {
    /**
     * The specified action is always allowed for the principal on resources matching the input.
     */
    PlanKind["ALWAYS_ALLOWED"] = "KIND_ALWAYS_ALLOWED";
    /**
     * The specified action is always denied for the principal on resources matching the input.
     */
    PlanKind["ALWAYS_DENIED"] = "KIND_ALWAYS_DENIED";
    /**
     * The specified action is conditionally allowed for the principal on resources matching the input.
     */
    PlanKind["CONDITIONAL"] = "KIND_CONDITIONAL";
})(PlanKind = exports.PlanKind || (exports.PlanKind = {}));
/**
 * Sources of invalid attributes.
 *
 * @public
 */
var ValidationErrorSource;
(function (ValidationErrorSource) {
    /**
     * The principal's attributes failed schema validation.
     */
    ValidationErrorSource["PRINCIPAL"] = "SOURCE_PRINCIPAL";
    /**
     * The resource's attributes failed schema validation.
     */
    ValidationErrorSource["RESOURCE"] = "SOURCE_RESOURCE";
})(ValidationErrorSource = exports.ValidationErrorSource || (exports.ValidationErrorSource = {}));
//# sourceMappingURL=types.js.map