"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TimestampRules = exports.DurationRules = exports.AnyRules = exports.MapRules = exports.RepeatedRules = exports.MessageRules = exports.EnumRules = exports.BytesRules = exports.StringRules = exports.BoolRules = exports.SFixed64Rules = exports.SFixed32Rules = exports.Fixed64Rules = exports.Fixed32Rules = exports.SInt64Rules = exports.SInt32Rules = exports.UInt64Rules = exports.UInt32Rules = exports.Int64Rules = exports.Int32Rules = exports.DoubleRules = exports.FloatRules = exports.FieldRules = exports.KnownRegex = exports.protobufPackage = void 0;
/* eslint-disable */
const timestamp_1 = require("../google/protobuf/timestamp");
const long_1 = __importDefault(require("long"));
const duration_1 = require("../google/protobuf/duration");
const _m0 = __importStar(require("protobufjs/minimal"));
exports.protobufPackage = "validate";
/** WellKnownRegex contain some well-known patterns. */
var KnownRegex;
(function (KnownRegex) {
    KnownRegex[KnownRegex["UNKNOWN"] = 0] = "UNKNOWN";
    /** HTTP_HEADER_NAME - HTTP header name as defined by RFC 7230. */
    KnownRegex[KnownRegex["HTTP_HEADER_NAME"] = 1] = "HTTP_HEADER_NAME";
    /** HTTP_HEADER_VALUE - HTTP header value as defined by RFC 7230. */
    KnownRegex[KnownRegex["HTTP_HEADER_VALUE"] = 2] = "HTTP_HEADER_VALUE";
})(KnownRegex = exports.KnownRegex || (exports.KnownRegex = {}));
function createBaseFieldRules() {
    return { message: undefined, type: undefined };
}
exports.FieldRules = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.message !== undefined) {
            exports.MessageRules.encode(message.message, writer.uint32(138).fork()).ldelim();
        }
        if (message.type?.$case === "float") {
            exports.FloatRules.encode(message.type.float, writer.uint32(10).fork()).ldelim();
        }
        if (message.type?.$case === "double") {
            exports.DoubleRules.encode(message.type.double, writer.uint32(18).fork()).ldelim();
        }
        if (message.type?.$case === "int32") {
            exports.Int32Rules.encode(message.type.int32, writer.uint32(26).fork()).ldelim();
        }
        if (message.type?.$case === "int64") {
            exports.Int64Rules.encode(message.type.int64, writer.uint32(34).fork()).ldelim();
        }
        if (message.type?.$case === "uint32") {
            exports.UInt32Rules.encode(message.type.uint32, writer.uint32(42).fork()).ldelim();
        }
        if (message.type?.$case === "uint64") {
            exports.UInt64Rules.encode(message.type.uint64, writer.uint32(50).fork()).ldelim();
        }
        if (message.type?.$case === "sint32") {
            exports.SInt32Rules.encode(message.type.sint32, writer.uint32(58).fork()).ldelim();
        }
        if (message.type?.$case === "sint64") {
            exports.SInt64Rules.encode(message.type.sint64, writer.uint32(66).fork()).ldelim();
        }
        if (message.type?.$case === "fixed32") {
            exports.Fixed32Rules.encode(message.type.fixed32, writer.uint32(74).fork()).ldelim();
        }
        if (message.type?.$case === "fixed64") {
            exports.Fixed64Rules.encode(message.type.fixed64, writer.uint32(82).fork()).ldelim();
        }
        if (message.type?.$case === "sfixed32") {
            exports.SFixed32Rules.encode(message.type.sfixed32, writer.uint32(90).fork()).ldelim();
        }
        if (message.type?.$case === "sfixed64") {
            exports.SFixed64Rules.encode(message.type.sfixed64, writer.uint32(98).fork()).ldelim();
        }
        if (message.type?.$case === "bool") {
            exports.BoolRules.encode(message.type.bool, writer.uint32(106).fork()).ldelim();
        }
        if (message.type?.$case === "string") {
            exports.StringRules.encode(message.type.string, writer.uint32(114).fork()).ldelim();
        }
        if (message.type?.$case === "bytes") {
            exports.BytesRules.encode(message.type.bytes, writer.uint32(122).fork()).ldelim();
        }
        if (message.type?.$case === "enum") {
            exports.EnumRules.encode(message.type.enum, writer.uint32(130).fork()).ldelim();
        }
        if (message.type?.$case === "repeated") {
            exports.RepeatedRules.encode(message.type.repeated, writer.uint32(146).fork()).ldelim();
        }
        if (message.type?.$case === "map") {
            exports.MapRules.encode(message.type.map, writer.uint32(154).fork()).ldelim();
        }
        if (message.type?.$case === "any") {
            exports.AnyRules.encode(message.type.any, writer.uint32(162).fork()).ldelim();
        }
        if (message.type?.$case === "duration") {
            exports.DurationRules.encode(message.type.duration, writer.uint32(170).fork()).ldelim();
        }
        if (message.type?.$case === "timestamp") {
            exports.TimestampRules.encode(message.type.timestamp, writer.uint32(178).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFieldRules();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 17:
                    message.message = exports.MessageRules.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.type = {
                        $case: "float",
                        float: exports.FloatRules.decode(reader, reader.uint32()),
                    };
                    break;
                case 2:
                    message.type = {
                        $case: "double",
                        double: exports.DoubleRules.decode(reader, reader.uint32()),
                    };
                    break;
                case 3:
                    message.type = {
                        $case: "int32",
                        int32: exports.Int32Rules.decode(reader, reader.uint32()),
                    };
                    break;
                case 4:
                    message.type = {
                        $case: "int64",
                        int64: exports.Int64Rules.decode(reader, reader.uint32()),
                    };
                    break;
                case 5:
                    message.type = {
                        $case: "uint32",
                        uint32: exports.UInt32Rules.decode(reader, reader.uint32()),
                    };
                    break;
                case 6:
                    message.type = {
                        $case: "uint64",
                        uint64: exports.UInt64Rules.decode(reader, reader.uint32()),
                    };
                    break;
                case 7:
                    message.type = {
                        $case: "sint32",
                        sint32: exports.SInt32Rules.decode(reader, reader.uint32()),
                    };
                    break;
                case 8:
                    message.type = {
                        $case: "sint64",
                        sint64: exports.SInt64Rules.decode(reader, reader.uint32()),
                    };
                    break;
                case 9:
                    message.type = {
                        $case: "fixed32",
                        fixed32: exports.Fixed32Rules.decode(reader, reader.uint32()),
                    };
                    break;
                case 10:
                    message.type = {
                        $case: "fixed64",
                        fixed64: exports.Fixed64Rules.decode(reader, reader.uint32()),
                    };
                    break;
                case 11:
                    message.type = {
                        $case: "sfixed32",
                        sfixed32: exports.SFixed32Rules.decode(reader, reader.uint32()),
                    };
                    break;
                case 12:
                    message.type = {
                        $case: "sfixed64",
                        sfixed64: exports.SFixed64Rules.decode(reader, reader.uint32()),
                    };
                    break;
                case 13:
                    message.type = {
                        $case: "bool",
                        bool: exports.BoolRules.decode(reader, reader.uint32()),
                    };
                    break;
                case 14:
                    message.type = {
                        $case: "string",
                        string: exports.StringRules.decode(reader, reader.uint32()),
                    };
                    break;
                case 15:
                    message.type = {
                        $case: "bytes",
                        bytes: exports.BytesRules.decode(reader, reader.uint32()),
                    };
                    break;
                case 16:
                    message.type = {
                        $case: "enum",
                        enum: exports.EnumRules.decode(reader, reader.uint32()),
                    };
                    break;
                case 18:
                    message.type = {
                        $case: "repeated",
                        repeated: exports.RepeatedRules.decode(reader, reader.uint32()),
                    };
                    break;
                case 19:
                    message.type = {
                        $case: "map",
                        map: exports.MapRules.decode(reader, reader.uint32()),
                    };
                    break;
                case 20:
                    message.type = {
                        $case: "any",
                        any: exports.AnyRules.decode(reader, reader.uint32()),
                    };
                    break;
                case 21:
                    message.type = {
                        $case: "duration",
                        duration: exports.DurationRules.decode(reader, reader.uint32()),
                    };
                    break;
                case 22:
                    message.type = {
                        $case: "timestamp",
                        timestamp: exports.TimestampRules.decode(reader, reader.uint32()),
                    };
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseFloatRules() {
    return {
        const: 0,
        lt: 0,
        lte: 0,
        gt: 0,
        gte: 0,
        in: [],
        notIn: [],
        ignoreEmpty: false,
    };
}
exports.FloatRules = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.const !== 0) {
            writer.uint32(13).float(message.const);
        }
        if (message.lt !== 0) {
            writer.uint32(21).float(message.lt);
        }
        if (message.lte !== 0) {
            writer.uint32(29).float(message.lte);
        }
        if (message.gt !== 0) {
            writer.uint32(37).float(message.gt);
        }
        if (message.gte !== 0) {
            writer.uint32(45).float(message.gte);
        }
        writer.uint32(50).fork();
        for (const v of message.in) {
            writer.float(v);
        }
        writer.ldelim();
        writer.uint32(58).fork();
        for (const v of message.notIn) {
            writer.float(v);
        }
        writer.ldelim();
        if (message.ignoreEmpty === true) {
            writer.uint32(64).bool(message.ignoreEmpty);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFloatRules();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.const = reader.float();
                    break;
                case 2:
                    message.lt = reader.float();
                    break;
                case 3:
                    message.lte = reader.float();
                    break;
                case 4:
                    message.gt = reader.float();
                    break;
                case 5:
                    message.gte = reader.float();
                    break;
                case 6:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.in.push(reader.float());
                        }
                    }
                    else {
                        message.in.push(reader.float());
                    }
                    break;
                case 7:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.notIn.push(reader.float());
                        }
                    }
                    else {
                        message.notIn.push(reader.float());
                    }
                    break;
                case 8:
                    message.ignoreEmpty = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseDoubleRules() {
    return {
        const: 0,
        lt: 0,
        lte: 0,
        gt: 0,
        gte: 0,
        in: [],
        notIn: [],
        ignoreEmpty: false,
    };
}
exports.DoubleRules = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.const !== 0) {
            writer.uint32(9).double(message.const);
        }
        if (message.lt !== 0) {
            writer.uint32(17).double(message.lt);
        }
        if (message.lte !== 0) {
            writer.uint32(25).double(message.lte);
        }
        if (message.gt !== 0) {
            writer.uint32(33).double(message.gt);
        }
        if (message.gte !== 0) {
            writer.uint32(41).double(message.gte);
        }
        writer.uint32(50).fork();
        for (const v of message.in) {
            writer.double(v);
        }
        writer.ldelim();
        writer.uint32(58).fork();
        for (const v of message.notIn) {
            writer.double(v);
        }
        writer.ldelim();
        if (message.ignoreEmpty === true) {
            writer.uint32(64).bool(message.ignoreEmpty);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDoubleRules();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.const = reader.double();
                    break;
                case 2:
                    message.lt = reader.double();
                    break;
                case 3:
                    message.lte = reader.double();
                    break;
                case 4:
                    message.gt = reader.double();
                    break;
                case 5:
                    message.gte = reader.double();
                    break;
                case 6:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.in.push(reader.double());
                        }
                    }
                    else {
                        message.in.push(reader.double());
                    }
                    break;
                case 7:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.notIn.push(reader.double());
                        }
                    }
                    else {
                        message.notIn.push(reader.double());
                    }
                    break;
                case 8:
                    message.ignoreEmpty = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseInt32Rules() {
    return {
        const: 0,
        lt: 0,
        lte: 0,
        gt: 0,
        gte: 0,
        in: [],
        notIn: [],
        ignoreEmpty: false,
    };
}
exports.Int32Rules = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.const !== 0) {
            writer.uint32(8).int32(message.const);
        }
        if (message.lt !== 0) {
            writer.uint32(16).int32(message.lt);
        }
        if (message.lte !== 0) {
            writer.uint32(24).int32(message.lte);
        }
        if (message.gt !== 0) {
            writer.uint32(32).int32(message.gt);
        }
        if (message.gte !== 0) {
            writer.uint32(40).int32(message.gte);
        }
        writer.uint32(50).fork();
        for (const v of message.in) {
            writer.int32(v);
        }
        writer.ldelim();
        writer.uint32(58).fork();
        for (const v of message.notIn) {
            writer.int32(v);
        }
        writer.ldelim();
        if (message.ignoreEmpty === true) {
            writer.uint32(64).bool(message.ignoreEmpty);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInt32Rules();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.const = reader.int32();
                    break;
                case 2:
                    message.lt = reader.int32();
                    break;
                case 3:
                    message.lte = reader.int32();
                    break;
                case 4:
                    message.gt = reader.int32();
                    break;
                case 5:
                    message.gte = reader.int32();
                    break;
                case 6:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.in.push(reader.int32());
                        }
                    }
                    else {
                        message.in.push(reader.int32());
                    }
                    break;
                case 7:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.notIn.push(reader.int32());
                        }
                    }
                    else {
                        message.notIn.push(reader.int32());
                    }
                    break;
                case 8:
                    message.ignoreEmpty = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseInt64Rules() {
    return {
        const: 0,
        lt: 0,
        lte: 0,
        gt: 0,
        gte: 0,
        in: [],
        notIn: [],
        ignoreEmpty: false,
    };
}
exports.Int64Rules = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.const !== 0) {
            writer.uint32(8).int64(message.const);
        }
        if (message.lt !== 0) {
            writer.uint32(16).int64(message.lt);
        }
        if (message.lte !== 0) {
            writer.uint32(24).int64(message.lte);
        }
        if (message.gt !== 0) {
            writer.uint32(32).int64(message.gt);
        }
        if (message.gte !== 0) {
            writer.uint32(40).int64(message.gte);
        }
        writer.uint32(50).fork();
        for (const v of message.in) {
            writer.int64(v);
        }
        writer.ldelim();
        writer.uint32(58).fork();
        for (const v of message.notIn) {
            writer.int64(v);
        }
        writer.ldelim();
        if (message.ignoreEmpty === true) {
            writer.uint32(64).bool(message.ignoreEmpty);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInt64Rules();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.const = longToNumber(reader.int64());
                    break;
                case 2:
                    message.lt = longToNumber(reader.int64());
                    break;
                case 3:
                    message.lte = longToNumber(reader.int64());
                    break;
                case 4:
                    message.gt = longToNumber(reader.int64());
                    break;
                case 5:
                    message.gte = longToNumber(reader.int64());
                    break;
                case 6:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.in.push(longToNumber(reader.int64()));
                        }
                    }
                    else {
                        message.in.push(longToNumber(reader.int64()));
                    }
                    break;
                case 7:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.notIn.push(longToNumber(reader.int64()));
                        }
                    }
                    else {
                        message.notIn.push(longToNumber(reader.int64()));
                    }
                    break;
                case 8:
                    message.ignoreEmpty = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseUInt32Rules() {
    return {
        const: 0,
        lt: 0,
        lte: 0,
        gt: 0,
        gte: 0,
        in: [],
        notIn: [],
        ignoreEmpty: false,
    };
}
exports.UInt32Rules = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.const !== 0) {
            writer.uint32(8).uint32(message.const);
        }
        if (message.lt !== 0) {
            writer.uint32(16).uint32(message.lt);
        }
        if (message.lte !== 0) {
            writer.uint32(24).uint32(message.lte);
        }
        if (message.gt !== 0) {
            writer.uint32(32).uint32(message.gt);
        }
        if (message.gte !== 0) {
            writer.uint32(40).uint32(message.gte);
        }
        writer.uint32(50).fork();
        for (const v of message.in) {
            writer.uint32(v);
        }
        writer.ldelim();
        writer.uint32(58).fork();
        for (const v of message.notIn) {
            writer.uint32(v);
        }
        writer.ldelim();
        if (message.ignoreEmpty === true) {
            writer.uint32(64).bool(message.ignoreEmpty);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUInt32Rules();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.const = reader.uint32();
                    break;
                case 2:
                    message.lt = reader.uint32();
                    break;
                case 3:
                    message.lte = reader.uint32();
                    break;
                case 4:
                    message.gt = reader.uint32();
                    break;
                case 5:
                    message.gte = reader.uint32();
                    break;
                case 6:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.in.push(reader.uint32());
                        }
                    }
                    else {
                        message.in.push(reader.uint32());
                    }
                    break;
                case 7:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.notIn.push(reader.uint32());
                        }
                    }
                    else {
                        message.notIn.push(reader.uint32());
                    }
                    break;
                case 8:
                    message.ignoreEmpty = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseUInt64Rules() {
    return {
        const: 0,
        lt: 0,
        lte: 0,
        gt: 0,
        gte: 0,
        in: [],
        notIn: [],
        ignoreEmpty: false,
    };
}
exports.UInt64Rules = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.const !== 0) {
            writer.uint32(8).uint64(message.const);
        }
        if (message.lt !== 0) {
            writer.uint32(16).uint64(message.lt);
        }
        if (message.lte !== 0) {
            writer.uint32(24).uint64(message.lte);
        }
        if (message.gt !== 0) {
            writer.uint32(32).uint64(message.gt);
        }
        if (message.gte !== 0) {
            writer.uint32(40).uint64(message.gte);
        }
        writer.uint32(50).fork();
        for (const v of message.in) {
            writer.uint64(v);
        }
        writer.ldelim();
        writer.uint32(58).fork();
        for (const v of message.notIn) {
            writer.uint64(v);
        }
        writer.ldelim();
        if (message.ignoreEmpty === true) {
            writer.uint32(64).bool(message.ignoreEmpty);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUInt64Rules();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.const = longToNumber(reader.uint64());
                    break;
                case 2:
                    message.lt = longToNumber(reader.uint64());
                    break;
                case 3:
                    message.lte = longToNumber(reader.uint64());
                    break;
                case 4:
                    message.gt = longToNumber(reader.uint64());
                    break;
                case 5:
                    message.gte = longToNumber(reader.uint64());
                    break;
                case 6:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.in.push(longToNumber(reader.uint64()));
                        }
                    }
                    else {
                        message.in.push(longToNumber(reader.uint64()));
                    }
                    break;
                case 7:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.notIn.push(longToNumber(reader.uint64()));
                        }
                    }
                    else {
                        message.notIn.push(longToNumber(reader.uint64()));
                    }
                    break;
                case 8:
                    message.ignoreEmpty = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSInt32Rules() {
    return {
        const: 0,
        lt: 0,
        lte: 0,
        gt: 0,
        gte: 0,
        in: [],
        notIn: [],
        ignoreEmpty: false,
    };
}
exports.SInt32Rules = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.const !== 0) {
            writer.uint32(8).sint32(message.const);
        }
        if (message.lt !== 0) {
            writer.uint32(16).sint32(message.lt);
        }
        if (message.lte !== 0) {
            writer.uint32(24).sint32(message.lte);
        }
        if (message.gt !== 0) {
            writer.uint32(32).sint32(message.gt);
        }
        if (message.gte !== 0) {
            writer.uint32(40).sint32(message.gte);
        }
        writer.uint32(50).fork();
        for (const v of message.in) {
            writer.sint32(v);
        }
        writer.ldelim();
        writer.uint32(58).fork();
        for (const v of message.notIn) {
            writer.sint32(v);
        }
        writer.ldelim();
        if (message.ignoreEmpty === true) {
            writer.uint32(64).bool(message.ignoreEmpty);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSInt32Rules();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.const = reader.sint32();
                    break;
                case 2:
                    message.lt = reader.sint32();
                    break;
                case 3:
                    message.lte = reader.sint32();
                    break;
                case 4:
                    message.gt = reader.sint32();
                    break;
                case 5:
                    message.gte = reader.sint32();
                    break;
                case 6:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.in.push(reader.sint32());
                        }
                    }
                    else {
                        message.in.push(reader.sint32());
                    }
                    break;
                case 7:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.notIn.push(reader.sint32());
                        }
                    }
                    else {
                        message.notIn.push(reader.sint32());
                    }
                    break;
                case 8:
                    message.ignoreEmpty = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSInt64Rules() {
    return {
        const: 0,
        lt: 0,
        lte: 0,
        gt: 0,
        gte: 0,
        in: [],
        notIn: [],
        ignoreEmpty: false,
    };
}
exports.SInt64Rules = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.const !== 0) {
            writer.uint32(8).sint64(message.const);
        }
        if (message.lt !== 0) {
            writer.uint32(16).sint64(message.lt);
        }
        if (message.lte !== 0) {
            writer.uint32(24).sint64(message.lte);
        }
        if (message.gt !== 0) {
            writer.uint32(32).sint64(message.gt);
        }
        if (message.gte !== 0) {
            writer.uint32(40).sint64(message.gte);
        }
        writer.uint32(50).fork();
        for (const v of message.in) {
            writer.sint64(v);
        }
        writer.ldelim();
        writer.uint32(58).fork();
        for (const v of message.notIn) {
            writer.sint64(v);
        }
        writer.ldelim();
        if (message.ignoreEmpty === true) {
            writer.uint32(64).bool(message.ignoreEmpty);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSInt64Rules();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.const = longToNumber(reader.sint64());
                    break;
                case 2:
                    message.lt = longToNumber(reader.sint64());
                    break;
                case 3:
                    message.lte = longToNumber(reader.sint64());
                    break;
                case 4:
                    message.gt = longToNumber(reader.sint64());
                    break;
                case 5:
                    message.gte = longToNumber(reader.sint64());
                    break;
                case 6:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.in.push(longToNumber(reader.sint64()));
                        }
                    }
                    else {
                        message.in.push(longToNumber(reader.sint64()));
                    }
                    break;
                case 7:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.notIn.push(longToNumber(reader.sint64()));
                        }
                    }
                    else {
                        message.notIn.push(longToNumber(reader.sint64()));
                    }
                    break;
                case 8:
                    message.ignoreEmpty = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseFixed32Rules() {
    return {
        const: 0,
        lt: 0,
        lte: 0,
        gt: 0,
        gte: 0,
        in: [],
        notIn: [],
        ignoreEmpty: false,
    };
}
exports.Fixed32Rules = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.const !== 0) {
            writer.uint32(13).fixed32(message.const);
        }
        if (message.lt !== 0) {
            writer.uint32(21).fixed32(message.lt);
        }
        if (message.lte !== 0) {
            writer.uint32(29).fixed32(message.lte);
        }
        if (message.gt !== 0) {
            writer.uint32(37).fixed32(message.gt);
        }
        if (message.gte !== 0) {
            writer.uint32(45).fixed32(message.gte);
        }
        writer.uint32(50).fork();
        for (const v of message.in) {
            writer.fixed32(v);
        }
        writer.ldelim();
        writer.uint32(58).fork();
        for (const v of message.notIn) {
            writer.fixed32(v);
        }
        writer.ldelim();
        if (message.ignoreEmpty === true) {
            writer.uint32(64).bool(message.ignoreEmpty);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFixed32Rules();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.const = reader.fixed32();
                    break;
                case 2:
                    message.lt = reader.fixed32();
                    break;
                case 3:
                    message.lte = reader.fixed32();
                    break;
                case 4:
                    message.gt = reader.fixed32();
                    break;
                case 5:
                    message.gte = reader.fixed32();
                    break;
                case 6:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.in.push(reader.fixed32());
                        }
                    }
                    else {
                        message.in.push(reader.fixed32());
                    }
                    break;
                case 7:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.notIn.push(reader.fixed32());
                        }
                    }
                    else {
                        message.notIn.push(reader.fixed32());
                    }
                    break;
                case 8:
                    message.ignoreEmpty = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseFixed64Rules() {
    return {
        const: 0,
        lt: 0,
        lte: 0,
        gt: 0,
        gte: 0,
        in: [],
        notIn: [],
        ignoreEmpty: false,
    };
}
exports.Fixed64Rules = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.const !== 0) {
            writer.uint32(9).fixed64(message.const);
        }
        if (message.lt !== 0) {
            writer.uint32(17).fixed64(message.lt);
        }
        if (message.lte !== 0) {
            writer.uint32(25).fixed64(message.lte);
        }
        if (message.gt !== 0) {
            writer.uint32(33).fixed64(message.gt);
        }
        if (message.gte !== 0) {
            writer.uint32(41).fixed64(message.gte);
        }
        writer.uint32(50).fork();
        for (const v of message.in) {
            writer.fixed64(v);
        }
        writer.ldelim();
        writer.uint32(58).fork();
        for (const v of message.notIn) {
            writer.fixed64(v);
        }
        writer.ldelim();
        if (message.ignoreEmpty === true) {
            writer.uint32(64).bool(message.ignoreEmpty);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFixed64Rules();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.const = longToNumber(reader.fixed64());
                    break;
                case 2:
                    message.lt = longToNumber(reader.fixed64());
                    break;
                case 3:
                    message.lte = longToNumber(reader.fixed64());
                    break;
                case 4:
                    message.gt = longToNumber(reader.fixed64());
                    break;
                case 5:
                    message.gte = longToNumber(reader.fixed64());
                    break;
                case 6:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.in.push(longToNumber(reader.fixed64()));
                        }
                    }
                    else {
                        message.in.push(longToNumber(reader.fixed64()));
                    }
                    break;
                case 7:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.notIn.push(longToNumber(reader.fixed64()));
                        }
                    }
                    else {
                        message.notIn.push(longToNumber(reader.fixed64()));
                    }
                    break;
                case 8:
                    message.ignoreEmpty = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSFixed32Rules() {
    return {
        const: 0,
        lt: 0,
        lte: 0,
        gt: 0,
        gte: 0,
        in: [],
        notIn: [],
        ignoreEmpty: false,
    };
}
exports.SFixed32Rules = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.const !== 0) {
            writer.uint32(13).sfixed32(message.const);
        }
        if (message.lt !== 0) {
            writer.uint32(21).sfixed32(message.lt);
        }
        if (message.lte !== 0) {
            writer.uint32(29).sfixed32(message.lte);
        }
        if (message.gt !== 0) {
            writer.uint32(37).sfixed32(message.gt);
        }
        if (message.gte !== 0) {
            writer.uint32(45).sfixed32(message.gte);
        }
        writer.uint32(50).fork();
        for (const v of message.in) {
            writer.sfixed32(v);
        }
        writer.ldelim();
        writer.uint32(58).fork();
        for (const v of message.notIn) {
            writer.sfixed32(v);
        }
        writer.ldelim();
        if (message.ignoreEmpty === true) {
            writer.uint32(64).bool(message.ignoreEmpty);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSFixed32Rules();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.const = reader.sfixed32();
                    break;
                case 2:
                    message.lt = reader.sfixed32();
                    break;
                case 3:
                    message.lte = reader.sfixed32();
                    break;
                case 4:
                    message.gt = reader.sfixed32();
                    break;
                case 5:
                    message.gte = reader.sfixed32();
                    break;
                case 6:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.in.push(reader.sfixed32());
                        }
                    }
                    else {
                        message.in.push(reader.sfixed32());
                    }
                    break;
                case 7:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.notIn.push(reader.sfixed32());
                        }
                    }
                    else {
                        message.notIn.push(reader.sfixed32());
                    }
                    break;
                case 8:
                    message.ignoreEmpty = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSFixed64Rules() {
    return {
        const: 0,
        lt: 0,
        lte: 0,
        gt: 0,
        gte: 0,
        in: [],
        notIn: [],
        ignoreEmpty: false,
    };
}
exports.SFixed64Rules = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.const !== 0) {
            writer.uint32(9).sfixed64(message.const);
        }
        if (message.lt !== 0) {
            writer.uint32(17).sfixed64(message.lt);
        }
        if (message.lte !== 0) {
            writer.uint32(25).sfixed64(message.lte);
        }
        if (message.gt !== 0) {
            writer.uint32(33).sfixed64(message.gt);
        }
        if (message.gte !== 0) {
            writer.uint32(41).sfixed64(message.gte);
        }
        writer.uint32(50).fork();
        for (const v of message.in) {
            writer.sfixed64(v);
        }
        writer.ldelim();
        writer.uint32(58).fork();
        for (const v of message.notIn) {
            writer.sfixed64(v);
        }
        writer.ldelim();
        if (message.ignoreEmpty === true) {
            writer.uint32(64).bool(message.ignoreEmpty);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSFixed64Rules();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.const = longToNumber(reader.sfixed64());
                    break;
                case 2:
                    message.lt = longToNumber(reader.sfixed64());
                    break;
                case 3:
                    message.lte = longToNumber(reader.sfixed64());
                    break;
                case 4:
                    message.gt = longToNumber(reader.sfixed64());
                    break;
                case 5:
                    message.gte = longToNumber(reader.sfixed64());
                    break;
                case 6:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.in.push(longToNumber(reader.sfixed64()));
                        }
                    }
                    else {
                        message.in.push(longToNumber(reader.sfixed64()));
                    }
                    break;
                case 7:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.notIn.push(longToNumber(reader.sfixed64()));
                        }
                    }
                    else {
                        message.notIn.push(longToNumber(reader.sfixed64()));
                    }
                    break;
                case 8:
                    message.ignoreEmpty = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseBoolRules() {
    return { const: false };
}
exports.BoolRules = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.const === true) {
            writer.uint32(8).bool(message.const);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBoolRules();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.const = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseStringRules() {
    return {
        const: "",
        len: 0,
        minLen: 0,
        maxLen: 0,
        lenBytes: 0,
        minBytes: 0,
        maxBytes: 0,
        pattern: "",
        prefix: "",
        suffix: "",
        contains: "",
        notContains: "",
        in: [],
        notIn: [],
        wellKnown: undefined,
        strict: false,
        ignoreEmpty: false,
    };
}
exports.StringRules = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.const !== "") {
            writer.uint32(10).string(message.const);
        }
        if (message.len !== 0) {
            writer.uint32(152).uint64(message.len);
        }
        if (message.minLen !== 0) {
            writer.uint32(16).uint64(message.minLen);
        }
        if (message.maxLen !== 0) {
            writer.uint32(24).uint64(message.maxLen);
        }
        if (message.lenBytes !== 0) {
            writer.uint32(160).uint64(message.lenBytes);
        }
        if (message.minBytes !== 0) {
            writer.uint32(32).uint64(message.minBytes);
        }
        if (message.maxBytes !== 0) {
            writer.uint32(40).uint64(message.maxBytes);
        }
        if (message.pattern !== "") {
            writer.uint32(50).string(message.pattern);
        }
        if (message.prefix !== "") {
            writer.uint32(58).string(message.prefix);
        }
        if (message.suffix !== "") {
            writer.uint32(66).string(message.suffix);
        }
        if (message.contains !== "") {
            writer.uint32(74).string(message.contains);
        }
        if (message.notContains !== "") {
            writer.uint32(186).string(message.notContains);
        }
        for (const v of message.in) {
            writer.uint32(82).string(v);
        }
        for (const v of message.notIn) {
            writer.uint32(90).string(v);
        }
        if (message.wellKnown?.$case === "email") {
            writer.uint32(96).bool(message.wellKnown.email);
        }
        if (message.wellKnown?.$case === "hostname") {
            writer.uint32(104).bool(message.wellKnown.hostname);
        }
        if (message.wellKnown?.$case === "ip") {
            writer.uint32(112).bool(message.wellKnown.ip);
        }
        if (message.wellKnown?.$case === "ipv4") {
            writer.uint32(120).bool(message.wellKnown.ipv4);
        }
        if (message.wellKnown?.$case === "ipv6") {
            writer.uint32(128).bool(message.wellKnown.ipv6);
        }
        if (message.wellKnown?.$case === "uri") {
            writer.uint32(136).bool(message.wellKnown.uri);
        }
        if (message.wellKnown?.$case === "uriRef") {
            writer.uint32(144).bool(message.wellKnown.uriRef);
        }
        if (message.wellKnown?.$case === "address") {
            writer.uint32(168).bool(message.wellKnown.address);
        }
        if (message.wellKnown?.$case === "uuid") {
            writer.uint32(176).bool(message.wellKnown.uuid);
        }
        if (message.wellKnown?.$case === "wellKnownRegex") {
            writer.uint32(192).int32(message.wellKnown.wellKnownRegex);
        }
        if (message.strict === true) {
            writer.uint32(200).bool(message.strict);
        }
        if (message.ignoreEmpty === true) {
            writer.uint32(208).bool(message.ignoreEmpty);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStringRules();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.const = reader.string();
                    break;
                case 19:
                    message.len = longToNumber(reader.uint64());
                    break;
                case 2:
                    message.minLen = longToNumber(reader.uint64());
                    break;
                case 3:
                    message.maxLen = longToNumber(reader.uint64());
                    break;
                case 20:
                    message.lenBytes = longToNumber(reader.uint64());
                    break;
                case 4:
                    message.minBytes = longToNumber(reader.uint64());
                    break;
                case 5:
                    message.maxBytes = longToNumber(reader.uint64());
                    break;
                case 6:
                    message.pattern = reader.string();
                    break;
                case 7:
                    message.prefix = reader.string();
                    break;
                case 8:
                    message.suffix = reader.string();
                    break;
                case 9:
                    message.contains = reader.string();
                    break;
                case 23:
                    message.notContains = reader.string();
                    break;
                case 10:
                    message.in.push(reader.string());
                    break;
                case 11:
                    message.notIn.push(reader.string());
                    break;
                case 12:
                    message.wellKnown = { $case: "email", email: reader.bool() };
                    break;
                case 13:
                    message.wellKnown = { $case: "hostname", hostname: reader.bool() };
                    break;
                case 14:
                    message.wellKnown = { $case: "ip", ip: reader.bool() };
                    break;
                case 15:
                    message.wellKnown = { $case: "ipv4", ipv4: reader.bool() };
                    break;
                case 16:
                    message.wellKnown = { $case: "ipv6", ipv6: reader.bool() };
                    break;
                case 17:
                    message.wellKnown = { $case: "uri", uri: reader.bool() };
                    break;
                case 18:
                    message.wellKnown = { $case: "uriRef", uriRef: reader.bool() };
                    break;
                case 21:
                    message.wellKnown = { $case: "address", address: reader.bool() };
                    break;
                case 22:
                    message.wellKnown = { $case: "uuid", uuid: reader.bool() };
                    break;
                case 24:
                    message.wellKnown = {
                        $case: "wellKnownRegex",
                        wellKnownRegex: reader.int32(),
                    };
                    break;
                case 25:
                    message.strict = reader.bool();
                    break;
                case 26:
                    message.ignoreEmpty = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseBytesRules() {
    return {
        const: Buffer.alloc(0),
        len: 0,
        minLen: 0,
        maxLen: 0,
        pattern: "",
        prefix: Buffer.alloc(0),
        suffix: Buffer.alloc(0),
        contains: Buffer.alloc(0),
        in: [],
        notIn: [],
        wellKnown: undefined,
        ignoreEmpty: false,
    };
}
exports.BytesRules = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.const.length !== 0) {
            writer.uint32(10).bytes(message.const);
        }
        if (message.len !== 0) {
            writer.uint32(104).uint64(message.len);
        }
        if (message.minLen !== 0) {
            writer.uint32(16).uint64(message.minLen);
        }
        if (message.maxLen !== 0) {
            writer.uint32(24).uint64(message.maxLen);
        }
        if (message.pattern !== "") {
            writer.uint32(34).string(message.pattern);
        }
        if (message.prefix.length !== 0) {
            writer.uint32(42).bytes(message.prefix);
        }
        if (message.suffix.length !== 0) {
            writer.uint32(50).bytes(message.suffix);
        }
        if (message.contains.length !== 0) {
            writer.uint32(58).bytes(message.contains);
        }
        for (const v of message.in) {
            writer.uint32(66).bytes(v);
        }
        for (const v of message.notIn) {
            writer.uint32(74).bytes(v);
        }
        if (message.wellKnown?.$case === "ip") {
            writer.uint32(80).bool(message.wellKnown.ip);
        }
        if (message.wellKnown?.$case === "ipv4") {
            writer.uint32(88).bool(message.wellKnown.ipv4);
        }
        if (message.wellKnown?.$case === "ipv6") {
            writer.uint32(96).bool(message.wellKnown.ipv6);
        }
        if (message.ignoreEmpty === true) {
            writer.uint32(112).bool(message.ignoreEmpty);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBytesRules();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.const = reader.bytes();
                    break;
                case 13:
                    message.len = longToNumber(reader.uint64());
                    break;
                case 2:
                    message.minLen = longToNumber(reader.uint64());
                    break;
                case 3:
                    message.maxLen = longToNumber(reader.uint64());
                    break;
                case 4:
                    message.pattern = reader.string();
                    break;
                case 5:
                    message.prefix = reader.bytes();
                    break;
                case 6:
                    message.suffix = reader.bytes();
                    break;
                case 7:
                    message.contains = reader.bytes();
                    break;
                case 8:
                    message.in.push(reader.bytes());
                    break;
                case 9:
                    message.notIn.push(reader.bytes());
                    break;
                case 10:
                    message.wellKnown = { $case: "ip", ip: reader.bool() };
                    break;
                case 11:
                    message.wellKnown = { $case: "ipv4", ipv4: reader.bool() };
                    break;
                case 12:
                    message.wellKnown = { $case: "ipv6", ipv6: reader.bool() };
                    break;
                case 14:
                    message.ignoreEmpty = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseEnumRules() {
    return { const: 0, definedOnly: false, in: [], notIn: [] };
}
exports.EnumRules = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.const !== 0) {
            writer.uint32(8).int32(message.const);
        }
        if (message.definedOnly === true) {
            writer.uint32(16).bool(message.definedOnly);
        }
        writer.uint32(26).fork();
        for (const v of message.in) {
            writer.int32(v);
        }
        writer.ldelim();
        writer.uint32(34).fork();
        for (const v of message.notIn) {
            writer.int32(v);
        }
        writer.ldelim();
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEnumRules();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.const = reader.int32();
                    break;
                case 2:
                    message.definedOnly = reader.bool();
                    break;
                case 3:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.in.push(reader.int32());
                        }
                    }
                    else {
                        message.in.push(reader.int32());
                    }
                    break;
                case 4:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.notIn.push(reader.int32());
                        }
                    }
                    else {
                        message.notIn.push(reader.int32());
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseMessageRules() {
    return { skip: false, required: false };
}
exports.MessageRules = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.skip === true) {
            writer.uint32(8).bool(message.skip);
        }
        if (message.required === true) {
            writer.uint32(16).bool(message.required);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMessageRules();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.skip = reader.bool();
                    break;
                case 2:
                    message.required = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseRepeatedRules() {
    return {
        minItems: 0,
        maxItems: 0,
        unique: false,
        items: undefined,
        ignoreEmpty: false,
    };
}
exports.RepeatedRules = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.minItems !== 0) {
            writer.uint32(8).uint64(message.minItems);
        }
        if (message.maxItems !== 0) {
            writer.uint32(16).uint64(message.maxItems);
        }
        if (message.unique === true) {
            writer.uint32(24).bool(message.unique);
        }
        if (message.items !== undefined) {
            exports.FieldRules.encode(message.items, writer.uint32(34).fork()).ldelim();
        }
        if (message.ignoreEmpty === true) {
            writer.uint32(40).bool(message.ignoreEmpty);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRepeatedRules();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.minItems = longToNumber(reader.uint64());
                    break;
                case 2:
                    message.maxItems = longToNumber(reader.uint64());
                    break;
                case 3:
                    message.unique = reader.bool();
                    break;
                case 4:
                    message.items = exports.FieldRules.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.ignoreEmpty = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseMapRules() {
    return {
        minPairs: 0,
        maxPairs: 0,
        noSparse: false,
        keys: undefined,
        values: undefined,
        ignoreEmpty: false,
    };
}
exports.MapRules = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.minPairs !== 0) {
            writer.uint32(8).uint64(message.minPairs);
        }
        if (message.maxPairs !== 0) {
            writer.uint32(16).uint64(message.maxPairs);
        }
        if (message.noSparse === true) {
            writer.uint32(24).bool(message.noSparse);
        }
        if (message.keys !== undefined) {
            exports.FieldRules.encode(message.keys, writer.uint32(34).fork()).ldelim();
        }
        if (message.values !== undefined) {
            exports.FieldRules.encode(message.values, writer.uint32(42).fork()).ldelim();
        }
        if (message.ignoreEmpty === true) {
            writer.uint32(48).bool(message.ignoreEmpty);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMapRules();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.minPairs = longToNumber(reader.uint64());
                    break;
                case 2:
                    message.maxPairs = longToNumber(reader.uint64());
                    break;
                case 3:
                    message.noSparse = reader.bool();
                    break;
                case 4:
                    message.keys = exports.FieldRules.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.values = exports.FieldRules.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.ignoreEmpty = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseAnyRules() {
    return { required: false, in: [], notIn: [] };
}
exports.AnyRules = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.required === true) {
            writer.uint32(8).bool(message.required);
        }
        for (const v of message.in) {
            writer.uint32(18).string(v);
        }
        for (const v of message.notIn) {
            writer.uint32(26).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAnyRules();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.required = reader.bool();
                    break;
                case 2:
                    message.in.push(reader.string());
                    break;
                case 3:
                    message.notIn.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseDurationRules() {
    return {
        required: false,
        const: undefined,
        lt: undefined,
        lte: undefined,
        gt: undefined,
        gte: undefined,
        in: [],
        notIn: [],
    };
}
exports.DurationRules = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.required === true) {
            writer.uint32(8).bool(message.required);
        }
        if (message.const !== undefined) {
            duration_1.Duration.encode(message.const, writer.uint32(18).fork()).ldelim();
        }
        if (message.lt !== undefined) {
            duration_1.Duration.encode(message.lt, writer.uint32(26).fork()).ldelim();
        }
        if (message.lte !== undefined) {
            duration_1.Duration.encode(message.lte, writer.uint32(34).fork()).ldelim();
        }
        if (message.gt !== undefined) {
            duration_1.Duration.encode(message.gt, writer.uint32(42).fork()).ldelim();
        }
        if (message.gte !== undefined) {
            duration_1.Duration.encode(message.gte, writer.uint32(50).fork()).ldelim();
        }
        for (const v of message.in) {
            duration_1.Duration.encode(v, writer.uint32(58).fork()).ldelim();
        }
        for (const v of message.notIn) {
            duration_1.Duration.encode(v, writer.uint32(66).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDurationRules();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.required = reader.bool();
                    break;
                case 2:
                    message.const = duration_1.Duration.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.lt = duration_1.Duration.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.lte = duration_1.Duration.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.gt = duration_1.Duration.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.gte = duration_1.Duration.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.in.push(duration_1.Duration.decode(reader, reader.uint32()));
                    break;
                case 8:
                    message.notIn.push(duration_1.Duration.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseTimestampRules() {
    return {
        required: false,
        const: undefined,
        lt: undefined,
        lte: undefined,
        gt: undefined,
        gte: undefined,
        ltNow: false,
        gtNow: false,
        within: undefined,
    };
}
exports.TimestampRules = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.required === true) {
            writer.uint32(8).bool(message.required);
        }
        if (message.const !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.const), writer.uint32(18).fork()).ldelim();
        }
        if (message.lt !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.lt), writer.uint32(26).fork()).ldelim();
        }
        if (message.lte !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.lte), writer.uint32(34).fork()).ldelim();
        }
        if (message.gt !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.gt), writer.uint32(42).fork()).ldelim();
        }
        if (message.gte !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.gte), writer.uint32(50).fork()).ldelim();
        }
        if (message.ltNow === true) {
            writer.uint32(56).bool(message.ltNow);
        }
        if (message.gtNow === true) {
            writer.uint32(64).bool(message.gtNow);
        }
        if (message.within !== undefined) {
            duration_1.Duration.encode(message.within, writer.uint32(74).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTimestampRules();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.required = reader.bool();
                    break;
                case 2:
                    message.const = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.lt = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.lte = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.gt = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.gte = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    break;
                case 7:
                    message.ltNow = reader.bool();
                    break;
                case 8:
                    message.gtNow = reader.bool();
                    break;
                case 9:
                    message.within = duration_1.Duration.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
var globalThis = (() => {
    if (typeof globalThis !== "undefined")
        return globalThis;
    if (typeof self !== "undefined")
        return self;
    if (typeof window !== "undefined")
        return window;
    if (typeof global !== "undefined")
        return global;
    throw "Unable to locate global object";
})();
function toTimestamp(date) {
    const seconds = date.getTime() / 1000;
    const nanos = (date.getTime() % 1000) * 1000000;
    return { seconds, nanos };
}
function fromTimestamp(t) {
    let millis = t.seconds * 1000;
    millis += t.nanos / 1000000;
    return new Date(millis);
}
function longToNumber(long) {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (_m0.util.Long !== long_1.default) {
    _m0.util.Long = long_1.default;
    _m0.configure();
}
//# sourceMappingURL=validate.js.map