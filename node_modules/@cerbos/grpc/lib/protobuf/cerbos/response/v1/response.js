"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReloadStoreResponse = exports.DeleteSchemaResponse = exports.GetSchemaResponse = exports.ListSchemasResponse = exports.AddOrUpdateSchemaResponse = exports.GetPolicyResponse = exports.ListPoliciesResponse = exports.ServerInfoResponse = exports.ListAuditLogEntriesResponse = exports.AddOrUpdatePolicyResponse = exports.PlaygroundProxyResponse = exports.PlaygroundEvaluateResponse_EvalResultList = exports.PlaygroundEvaluateResponse_EvalResult = exports.PlaygroundEvaluateResponse = exports.PlaygroundTestResponse_TestResults = exports.PlaygroundTestResponse = exports.PlaygroundValidateResponse = exports.PlaygroundFailure_Error = exports.PlaygroundFailure = exports.CheckResourcesResponse_ResultEntry_ActionsEntry = exports.CheckResourcesResponse_ResultEntry_Meta_ActionsEntry = exports.CheckResourcesResponse_ResultEntry_Meta_EffectMeta = exports.CheckResourcesResponse_ResultEntry_Meta = exports.CheckResourcesResponse_ResultEntry_Resource = exports.CheckResourcesResponse_ResultEntry = exports.CheckResourcesResponse = exports.CheckResourceBatchResponse_ActionEffectMap_ActionsEntry = exports.CheckResourceBatchResponse_ActionEffectMap = exports.CheckResourceBatchResponse = exports.CheckResourceSetResponse_ResourceInstancesEntry = exports.CheckResourceSetResponse_Meta_ResourceInstancesEntry = exports.CheckResourceSetResponse_Meta_ActionMeta_ActionsEntry = exports.CheckResourceSetResponse_Meta_ActionMeta = exports.CheckResourceSetResponse_Meta_EffectMeta = exports.CheckResourceSetResponse_Meta = exports.CheckResourceSetResponse_ActionEffectMap_ActionsEntry = exports.CheckResourceSetResponse_ActionEffectMap = exports.CheckResourceSetResponse = exports.PlanResourcesResponse_Meta = exports.PlanResourcesResponse = exports.protobufPackage = void 0;
const engine_1 = require("../../../cerbos/engine/v1/engine");
const schema_1 = require("../../../cerbos/schema/v1/schema");
const policy_1 = require("../../../cerbos/policy/v1/policy");
const empty_1 = require("../../../google/protobuf/empty");
const audit_1 = require("../../../cerbos/audit/v1/audit");
const _m0 = __importStar(require("protobufjs/minimal"));
exports.protobufPackage = "cerbos.response.v1";
function createBasePlanResourcesResponse() {
    return {
        requestId: "",
        action: "",
        resourceKind: "",
        policyVersion: "",
        filter: undefined,
        meta: undefined,
        validationErrors: [],
    };
}
exports.PlanResourcesResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.requestId !== "") {
            writer.uint32(10).string(message.requestId);
        }
        if (message.action !== "") {
            writer.uint32(18).string(message.action);
        }
        if (message.resourceKind !== "") {
            writer.uint32(26).string(message.resourceKind);
        }
        if (message.policyVersion !== "") {
            writer.uint32(34).string(message.policyVersion);
        }
        if (message.filter !== undefined) {
            engine_1.PlanResourcesFilter.encode(message.filter, writer.uint32(42).fork()).ldelim();
        }
        if (message.meta !== undefined) {
            exports.PlanResourcesResponse_Meta.encode(message.meta, writer.uint32(50).fork()).ldelim();
        }
        for (const v of message.validationErrors) {
            schema_1.ValidationError.encode(v, writer.uint32(58).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlanResourcesResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.requestId = reader.string();
                    break;
                case 2:
                    message.action = reader.string();
                    break;
                case 3:
                    message.resourceKind = reader.string();
                    break;
                case 4:
                    message.policyVersion = reader.string();
                    break;
                case 5:
                    message.filter = engine_1.PlanResourcesFilter.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.meta = exports.PlanResourcesResponse_Meta.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.validationErrors.push(schema_1.ValidationError.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlanResourcesResponse_Meta() {
    return { filterDebug: "", matchedScope: "" };
}
exports.PlanResourcesResponse_Meta = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.filterDebug !== "") {
            writer.uint32(10).string(message.filterDebug);
        }
        if (message.matchedScope !== "") {
            writer.uint32(18).string(message.matchedScope);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlanResourcesResponse_Meta();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.filterDebug = reader.string();
                    break;
                case 2:
                    message.matchedScope = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseCheckResourceSetResponse() {
    return { requestId: "", resourceInstances: {}, meta: undefined };
}
exports.CheckResourceSetResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.requestId !== "") {
            writer.uint32(10).string(message.requestId);
        }
        Object.entries(message.resourceInstances).forEach(([key, value]) => {
            exports.CheckResourceSetResponse_ResourceInstancesEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();
        });
        if (message.meta !== undefined) {
            exports.CheckResourceSetResponse_Meta.encode(message.meta, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCheckResourceSetResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.requestId = reader.string();
                    break;
                case 2:
                    const entry2 = exports.CheckResourceSetResponse_ResourceInstancesEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.resourceInstances[entry2.key] = entry2.value;
                    }
                    break;
                case 3:
                    message.meta = exports.CheckResourceSetResponse_Meta.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseCheckResourceSetResponse_ActionEffectMap() {
    return { actions: {}, validationErrors: [] };
}
exports.CheckResourceSetResponse_ActionEffectMap = {
    encode(message, writer = _m0.Writer.create()) {
        Object.entries(message.actions).forEach(([key, value]) => {
            exports.CheckResourceSetResponse_ActionEffectMap_ActionsEntry.encode({ key: key, value }, writer.uint32(10).fork()).ldelim();
        });
        for (const v of message.validationErrors) {
            schema_1.ValidationError.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCheckResourceSetResponse_ActionEffectMap();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    const entry1 = exports.CheckResourceSetResponse_ActionEffectMap_ActionsEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.actions[entry1.key] = entry1.value;
                    }
                    break;
                case 2:
                    message.validationErrors.push(schema_1.ValidationError.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseCheckResourceSetResponse_ActionEffectMap_ActionsEntry() {
    return { key: "", value: 0 };
}
exports.CheckResourceSetResponse_ActionEffectMap_ActionsEntry = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== 0) {
            writer.uint32(16).int32(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCheckResourceSetResponse_ActionEffectMap_ActionsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseCheckResourceSetResponse_Meta() {
    return { resourceInstances: {} };
}
exports.CheckResourceSetResponse_Meta = {
    encode(message, writer = _m0.Writer.create()) {
        Object.entries(message.resourceInstances).forEach(([key, value]) => {
            exports.CheckResourceSetResponse_Meta_ResourceInstancesEntry.encode({ key: key, value }, writer.uint32(10).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCheckResourceSetResponse_Meta();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    const entry1 = exports.CheckResourceSetResponse_Meta_ResourceInstancesEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.resourceInstances[entry1.key] = entry1.value;
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseCheckResourceSetResponse_Meta_EffectMeta() {
    return { matchedPolicy: "", matchedScope: "" };
}
exports.CheckResourceSetResponse_Meta_EffectMeta = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.matchedPolicy !== "") {
            writer.uint32(10).string(message.matchedPolicy);
        }
        if (message.matchedScope !== "") {
            writer.uint32(18).string(message.matchedScope);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCheckResourceSetResponse_Meta_EffectMeta();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.matchedPolicy = reader.string();
                    break;
                case 2:
                    message.matchedScope = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseCheckResourceSetResponse_Meta_ActionMeta() {
    return { actions: {}, effectiveDerivedRoles: [] };
}
exports.CheckResourceSetResponse_Meta_ActionMeta = {
    encode(message, writer = _m0.Writer.create()) {
        Object.entries(message.actions).forEach(([key, value]) => {
            exports.CheckResourceSetResponse_Meta_ActionMeta_ActionsEntry.encode({ key: key, value }, writer.uint32(10).fork()).ldelim();
        });
        for (const v of message.effectiveDerivedRoles) {
            writer.uint32(18).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCheckResourceSetResponse_Meta_ActionMeta();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    const entry1 = exports.CheckResourceSetResponse_Meta_ActionMeta_ActionsEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.actions[entry1.key] = entry1.value;
                    }
                    break;
                case 2:
                    message.effectiveDerivedRoles.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseCheckResourceSetResponse_Meta_ActionMeta_ActionsEntry() {
    return { key: "", value: undefined };
}
exports.CheckResourceSetResponse_Meta_ActionMeta_ActionsEntry = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            exports.CheckResourceSetResponse_Meta_EffectMeta.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCheckResourceSetResponse_Meta_ActionMeta_ActionsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = exports.CheckResourceSetResponse_Meta_EffectMeta.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseCheckResourceSetResponse_Meta_ResourceInstancesEntry() {
    return { key: "", value: undefined };
}
exports.CheckResourceSetResponse_Meta_ResourceInstancesEntry = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            exports.CheckResourceSetResponse_Meta_ActionMeta.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCheckResourceSetResponse_Meta_ResourceInstancesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = exports.CheckResourceSetResponse_Meta_ActionMeta.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseCheckResourceSetResponse_ResourceInstancesEntry() {
    return { key: "", value: undefined };
}
exports.CheckResourceSetResponse_ResourceInstancesEntry = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            exports.CheckResourceSetResponse_ActionEffectMap.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCheckResourceSetResponse_ResourceInstancesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = exports.CheckResourceSetResponse_ActionEffectMap.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseCheckResourceBatchResponse() {
    return { requestId: "", results: [] };
}
exports.CheckResourceBatchResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.requestId !== "") {
            writer.uint32(10).string(message.requestId);
        }
        for (const v of message.results) {
            exports.CheckResourceBatchResponse_ActionEffectMap.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCheckResourceBatchResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.requestId = reader.string();
                    break;
                case 2:
                    message.results.push(exports.CheckResourceBatchResponse_ActionEffectMap.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseCheckResourceBatchResponse_ActionEffectMap() {
    return { resourceId: "", actions: {}, validationErrors: [] };
}
exports.CheckResourceBatchResponse_ActionEffectMap = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.resourceId !== "") {
            writer.uint32(10).string(message.resourceId);
        }
        Object.entries(message.actions).forEach(([key, value]) => {
            exports.CheckResourceBatchResponse_ActionEffectMap_ActionsEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();
        });
        for (const v of message.validationErrors) {
            schema_1.ValidationError.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCheckResourceBatchResponse_ActionEffectMap();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.resourceId = reader.string();
                    break;
                case 2:
                    const entry2 = exports.CheckResourceBatchResponse_ActionEffectMap_ActionsEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.actions[entry2.key] = entry2.value;
                    }
                    break;
                case 3:
                    message.validationErrors.push(schema_1.ValidationError.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseCheckResourceBatchResponse_ActionEffectMap_ActionsEntry() {
    return { key: "", value: 0 };
}
exports.CheckResourceBatchResponse_ActionEffectMap_ActionsEntry = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== 0) {
            writer.uint32(16).int32(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCheckResourceBatchResponse_ActionEffectMap_ActionsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseCheckResourcesResponse() {
    return { requestId: "", results: [] };
}
exports.CheckResourcesResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.requestId !== "") {
            writer.uint32(10).string(message.requestId);
        }
        for (const v of message.results) {
            exports.CheckResourcesResponse_ResultEntry.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCheckResourcesResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.requestId = reader.string();
                    break;
                case 2:
                    message.results.push(exports.CheckResourcesResponse_ResultEntry.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseCheckResourcesResponse_ResultEntry() {
    return {
        resource: undefined,
        actions: {},
        validationErrors: [],
        meta: undefined,
    };
}
exports.CheckResourcesResponse_ResultEntry = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.resource !== undefined) {
            exports.CheckResourcesResponse_ResultEntry_Resource.encode(message.resource, writer.uint32(10).fork()).ldelim();
        }
        Object.entries(message.actions).forEach(([key, value]) => {
            exports.CheckResourcesResponse_ResultEntry_ActionsEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();
        });
        for (const v of message.validationErrors) {
            schema_1.ValidationError.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (message.meta !== undefined) {
            exports.CheckResourcesResponse_ResultEntry_Meta.encode(message.meta, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCheckResourcesResponse_ResultEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.resource = exports.CheckResourcesResponse_ResultEntry_Resource.decode(reader, reader.uint32());
                    break;
                case 2:
                    const entry2 = exports.CheckResourcesResponse_ResultEntry_ActionsEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.actions[entry2.key] = entry2.value;
                    }
                    break;
                case 3:
                    message.validationErrors.push(schema_1.ValidationError.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.meta = exports.CheckResourcesResponse_ResultEntry_Meta.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseCheckResourcesResponse_ResultEntry_Resource() {
    return { id: "", kind: "", policyVersion: "", scope: "" };
}
exports.CheckResourcesResponse_ResultEntry_Resource = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.kind !== "") {
            writer.uint32(18).string(message.kind);
        }
        if (message.policyVersion !== "") {
            writer.uint32(26).string(message.policyVersion);
        }
        if (message.scope !== "") {
            writer.uint32(34).string(message.scope);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCheckResourcesResponse_ResultEntry_Resource();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.kind = reader.string();
                    break;
                case 3:
                    message.policyVersion = reader.string();
                    break;
                case 4:
                    message.scope = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseCheckResourcesResponse_ResultEntry_Meta() {
    return { actions: {}, effectiveDerivedRoles: [] };
}
exports.CheckResourcesResponse_ResultEntry_Meta = {
    encode(message, writer = _m0.Writer.create()) {
        Object.entries(message.actions).forEach(([key, value]) => {
            exports.CheckResourcesResponse_ResultEntry_Meta_ActionsEntry.encode({ key: key, value }, writer.uint32(10).fork()).ldelim();
        });
        for (const v of message.effectiveDerivedRoles) {
            writer.uint32(18).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCheckResourcesResponse_ResultEntry_Meta();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    const entry1 = exports.CheckResourcesResponse_ResultEntry_Meta_ActionsEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.actions[entry1.key] = entry1.value;
                    }
                    break;
                case 2:
                    message.effectiveDerivedRoles.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseCheckResourcesResponse_ResultEntry_Meta_EffectMeta() {
    return { matchedPolicy: "", matchedScope: "" };
}
exports.CheckResourcesResponse_ResultEntry_Meta_EffectMeta = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.matchedPolicy !== "") {
            writer.uint32(10).string(message.matchedPolicy);
        }
        if (message.matchedScope !== "") {
            writer.uint32(18).string(message.matchedScope);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCheckResourcesResponse_ResultEntry_Meta_EffectMeta();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.matchedPolicy = reader.string();
                    break;
                case 2:
                    message.matchedScope = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseCheckResourcesResponse_ResultEntry_Meta_ActionsEntry() {
    return { key: "", value: undefined };
}
exports.CheckResourcesResponse_ResultEntry_Meta_ActionsEntry = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            exports.CheckResourcesResponse_ResultEntry_Meta_EffectMeta.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCheckResourcesResponse_ResultEntry_Meta_ActionsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value =
                        exports.CheckResourcesResponse_ResultEntry_Meta_EffectMeta.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseCheckResourcesResponse_ResultEntry_ActionsEntry() {
    return { key: "", value: 0 };
}
exports.CheckResourcesResponse_ResultEntry_ActionsEntry = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== 0) {
            writer.uint32(16).int32(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCheckResourcesResponse_ResultEntry_ActionsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlaygroundFailure() {
    return { errors: [] };
}
exports.PlaygroundFailure = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.errors) {
            exports.PlaygroundFailure_Error.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlaygroundFailure();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.errors.push(exports.PlaygroundFailure_Error.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlaygroundFailure_Error() {
    return { file: "", error: "" };
}
exports.PlaygroundFailure_Error = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.file !== "") {
            writer.uint32(10).string(message.file);
        }
        if (message.error !== "") {
            writer.uint32(18).string(message.error);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlaygroundFailure_Error();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.file = reader.string();
                    break;
                case 2:
                    message.error = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlaygroundValidateResponse() {
    return { playgroundId: "", outcome: undefined };
}
exports.PlaygroundValidateResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.playgroundId !== "") {
            writer.uint32(10).string(message.playgroundId);
        }
        if (message.outcome?.$case === "failure") {
            exports.PlaygroundFailure.encode(message.outcome.failure, writer.uint32(18).fork()).ldelim();
        }
        if (message.outcome?.$case === "success") {
            empty_1.Empty.encode(message.outcome.success, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlaygroundValidateResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.playgroundId = reader.string();
                    break;
                case 2:
                    message.outcome = {
                        $case: "failure",
                        failure: exports.PlaygroundFailure.decode(reader, reader.uint32()),
                    };
                    break;
                case 3:
                    message.outcome = {
                        $case: "success",
                        success: empty_1.Empty.decode(reader, reader.uint32()),
                    };
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlaygroundTestResponse() {
    return { playgroundId: "", outcome: undefined };
}
exports.PlaygroundTestResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.playgroundId !== "") {
            writer.uint32(10).string(message.playgroundId);
        }
        if (message.outcome?.$case === "failure") {
            exports.PlaygroundFailure.encode(message.outcome.failure, writer.uint32(18).fork()).ldelim();
        }
        if (message.outcome?.$case === "success") {
            exports.PlaygroundTestResponse_TestResults.encode(message.outcome.success, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlaygroundTestResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.playgroundId = reader.string();
                    break;
                case 2:
                    message.outcome = {
                        $case: "failure",
                        failure: exports.PlaygroundFailure.decode(reader, reader.uint32()),
                    };
                    break;
                case 3:
                    message.outcome = {
                        $case: "success",
                        success: exports.PlaygroundTestResponse_TestResults.decode(reader, reader.uint32()),
                    };
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlaygroundTestResponse_TestResults() {
    return { results: undefined };
}
exports.PlaygroundTestResponse_TestResults = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.results !== undefined) {
            policy_1.TestResults.encode(message.results, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlaygroundTestResponse_TestResults();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.results = policy_1.TestResults.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlaygroundEvaluateResponse() {
    return { playgroundId: "", outcome: undefined };
}
exports.PlaygroundEvaluateResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.playgroundId !== "") {
            writer.uint32(10).string(message.playgroundId);
        }
        if (message.outcome?.$case === "failure") {
            exports.PlaygroundFailure.encode(message.outcome.failure, writer.uint32(18).fork()).ldelim();
        }
        if (message.outcome?.$case === "success") {
            exports.PlaygroundEvaluateResponse_EvalResultList.encode(message.outcome.success, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlaygroundEvaluateResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.playgroundId = reader.string();
                    break;
                case 2:
                    message.outcome = {
                        $case: "failure",
                        failure: exports.PlaygroundFailure.decode(reader, reader.uint32()),
                    };
                    break;
                case 3:
                    message.outcome = {
                        $case: "success",
                        success: exports.PlaygroundEvaluateResponse_EvalResultList.decode(reader, reader.uint32()),
                    };
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlaygroundEvaluateResponse_EvalResult() {
    return {
        action: "",
        effect: 0,
        policy: "",
        effectiveDerivedRoles: [],
        validationErrors: [],
    };
}
exports.PlaygroundEvaluateResponse_EvalResult = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.action !== "") {
            writer.uint32(10).string(message.action);
        }
        if (message.effect !== 0) {
            writer.uint32(16).int32(message.effect);
        }
        if (message.policy !== "") {
            writer.uint32(26).string(message.policy);
        }
        for (const v of message.effectiveDerivedRoles) {
            writer.uint32(34).string(v);
        }
        for (const v of message.validationErrors) {
            schema_1.ValidationError.encode(v, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlaygroundEvaluateResponse_EvalResult();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.action = reader.string();
                    break;
                case 2:
                    message.effect = reader.int32();
                    break;
                case 3:
                    message.policy = reader.string();
                    break;
                case 4:
                    message.effectiveDerivedRoles.push(reader.string());
                    break;
                case 5:
                    message.validationErrors.push(schema_1.ValidationError.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlaygroundEvaluateResponse_EvalResultList() {
    return { results: [] };
}
exports.PlaygroundEvaluateResponse_EvalResultList = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.results) {
            exports.PlaygroundEvaluateResponse_EvalResult.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlaygroundEvaluateResponse_EvalResultList();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.results.push(exports.PlaygroundEvaluateResponse_EvalResult.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlaygroundProxyResponse() {
    return { playgroundId: "", outcome: undefined };
}
exports.PlaygroundProxyResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.playgroundId !== "") {
            writer.uint32(10).string(message.playgroundId);
        }
        if (message.outcome?.$case === "failure") {
            exports.PlaygroundFailure.encode(message.outcome.failure, writer.uint32(18).fork()).ldelim();
        }
        if (message.outcome?.$case === "checkResourceSet") {
            exports.CheckResourceSetResponse.encode(message.outcome.checkResourceSet, writer.uint32(26).fork()).ldelim();
        }
        if (message.outcome?.$case === "checkResourceBatch") {
            exports.CheckResourceBatchResponse.encode(message.outcome.checkResourceBatch, writer.uint32(34).fork()).ldelim();
        }
        if (message.outcome?.$case === "planResources") {
            exports.PlanResourcesResponse.encode(message.outcome.planResources, writer.uint32(42).fork()).ldelim();
        }
        if (message.outcome?.$case === "checkResources") {
            exports.CheckResourcesResponse.encode(message.outcome.checkResources, writer.uint32(50).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlaygroundProxyResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.playgroundId = reader.string();
                    break;
                case 2:
                    message.outcome = {
                        $case: "failure",
                        failure: exports.PlaygroundFailure.decode(reader, reader.uint32()),
                    };
                    break;
                case 3:
                    message.outcome = {
                        $case: "checkResourceSet",
                        checkResourceSet: exports.CheckResourceSetResponse.decode(reader, reader.uint32()),
                    };
                    break;
                case 4:
                    message.outcome = {
                        $case: "checkResourceBatch",
                        checkResourceBatch: exports.CheckResourceBatchResponse.decode(reader, reader.uint32()),
                    };
                    break;
                case 5:
                    message.outcome = {
                        $case: "planResources",
                        planResources: exports.PlanResourcesResponse.decode(reader, reader.uint32()),
                    };
                    break;
                case 6:
                    message.outcome = {
                        $case: "checkResources",
                        checkResources: exports.CheckResourcesResponse.decode(reader, reader.uint32()),
                    };
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseAddOrUpdatePolicyResponse() {
    return { success: undefined };
}
exports.AddOrUpdatePolicyResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.success !== undefined) {
            empty_1.Empty.encode(message.success, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAddOrUpdatePolicyResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.success = empty_1.Empty.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseListAuditLogEntriesResponse() {
    return { entry: undefined };
}
exports.ListAuditLogEntriesResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.entry?.$case === "accessLogEntry") {
            audit_1.AccessLogEntry.encode(message.entry.accessLogEntry, writer.uint32(10).fork()).ldelim();
        }
        if (message.entry?.$case === "decisionLogEntry") {
            audit_1.DecisionLogEntry.encode(message.entry.decisionLogEntry, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseListAuditLogEntriesResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.entry = {
                        $case: "accessLogEntry",
                        accessLogEntry: audit_1.AccessLogEntry.decode(reader, reader.uint32()),
                    };
                    break;
                case 2:
                    message.entry = {
                        $case: "decisionLogEntry",
                        decisionLogEntry: audit_1.DecisionLogEntry.decode(reader, reader.uint32()),
                    };
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseServerInfoResponse() {
    return { version: "", commit: "", buildDate: "" };
}
exports.ServerInfoResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.version !== "") {
            writer.uint32(10).string(message.version);
        }
        if (message.commit !== "") {
            writer.uint32(18).string(message.commit);
        }
        if (message.buildDate !== "") {
            writer.uint32(26).string(message.buildDate);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseServerInfoResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.version = reader.string();
                    break;
                case 2:
                    message.commit = reader.string();
                    break;
                case 3:
                    message.buildDate = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseListPoliciesResponse() {
    return { policyIds: [] };
}
exports.ListPoliciesResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.policyIds) {
            writer.uint32(10).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseListPoliciesResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.policyIds.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseGetPolicyResponse() {
    return { policies: [] };
}
exports.GetPolicyResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.policies) {
            policy_1.Policy.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetPolicyResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.policies.push(policy_1.Policy.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseAddOrUpdateSchemaResponse() {
    return {};
}
exports.AddOrUpdateSchemaResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAddOrUpdateSchemaResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseListSchemasResponse() {
    return { schemaIds: [] };
}
exports.ListSchemasResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.schemaIds) {
            writer.uint32(10).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseListSchemasResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.schemaIds.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseGetSchemaResponse() {
    return { schemas: [] };
}
exports.GetSchemaResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.schemas) {
            schema_1.Schema.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetSchemaResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.schemas.push(schema_1.Schema.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseDeleteSchemaResponse() {
    return {};
}
exports.DeleteSchemaResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDeleteSchemaResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseReloadStoreResponse() {
    return {};
}
exports.ReloadStoreResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseReloadStoreResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
//# sourceMappingURL=response.js.map