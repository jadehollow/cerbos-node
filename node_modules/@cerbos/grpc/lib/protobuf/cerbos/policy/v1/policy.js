"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TestResults_Failure = exports.TestResults_Details = exports.TestResults_Action = exports.TestResults_Resource = exports.TestResults_Principal = exports.TestResults_Suite = exports.TestResults_Summary = exports.TestResults_Tally = exports.TestResults = exports.Test_ExpectedEntry = exports.Test_TestName = exports.Test = exports.TestTable_Expectation_ActionsEntry = exports.TestTable_Expectation = exports.TestTable_Input = exports.TestTable = exports.TestSuite_AuxDataEntry = exports.TestSuite_ResourcesEntry = exports.TestSuite_PrincipalsEntry = exports.TestSuite = exports.TestFixture_AuxData_AuxDataEntry = exports.TestFixture_AuxData = exports.TestFixture_Resources_ResourcesEntry = exports.TestFixture_Resources = exports.TestFixture_Principals_PrincipalsEntry = exports.TestFixture_Principals = exports.TestFixture = exports.Schemas_Schema = exports.Schemas_IgnoreWhen = exports.Schemas = exports.Match_ExprList = exports.Match = exports.Condition = exports.RoleDef = exports.DerivedRoles = exports.PrincipalRule_Action = exports.PrincipalRule = exports.PrincipalPolicy = exports.ResourceRule = exports.ResourcePolicy = exports.Metadata_AnnotationsEntry = exports.Metadata = exports.Policy_VariablesEntry = exports.Policy = exports.TestResults_Result = exports.protobufPackage = void 0;
const engine_1 = require("../../../cerbos/engine/v1/engine");
const _m0 = __importStar(require("protobufjs/minimal"));
const wrappers_1 = require("../../../google/protobuf/wrappers");
exports.protobufPackage = "cerbos.policy.v1";
var TestResults_Result;
(function (TestResults_Result) {
    TestResults_Result[TestResults_Result["RESULT_UNSPECIFIED"] = 0] = "RESULT_UNSPECIFIED";
    TestResults_Result[TestResults_Result["RESULT_SKIPPED"] = 1] = "RESULT_SKIPPED";
    TestResults_Result[TestResults_Result["RESULT_PASSED"] = 2] = "RESULT_PASSED";
    TestResults_Result[TestResults_Result["RESULT_FAILED"] = 3] = "RESULT_FAILED";
    TestResults_Result[TestResults_Result["RESULT_ERRORED"] = 4] = "RESULT_ERRORED";
})(TestResults_Result = exports.TestResults_Result || (exports.TestResults_Result = {}));
function createBasePolicy() {
    return {
        apiVersion: "",
        disabled: false,
        description: "",
        metadata: undefined,
        policyType: undefined,
        variables: {},
    };
}
exports.Policy = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.apiVersion !== "") {
            writer.uint32(10).string(message.apiVersion);
        }
        if (message.disabled === true) {
            writer.uint32(16).bool(message.disabled);
        }
        if (message.description !== "") {
            writer.uint32(26).string(message.description);
        }
        if (message.metadata !== undefined) {
            exports.Metadata.encode(message.metadata, writer.uint32(34).fork()).ldelim();
        }
        if (message.policyType?.$case === "resourcePolicy") {
            exports.ResourcePolicy.encode(message.policyType.resourcePolicy, writer.uint32(42).fork()).ldelim();
        }
        if (message.policyType?.$case === "principalPolicy") {
            exports.PrincipalPolicy.encode(message.policyType.principalPolicy, writer.uint32(50).fork()).ldelim();
        }
        if (message.policyType?.$case === "derivedRoles") {
            exports.DerivedRoles.encode(message.policyType.derivedRoles, writer.uint32(58).fork()).ldelim();
        }
        Object.entries(message.variables).forEach(([key, value]) => {
            exports.Policy_VariablesEntry.encode({ key: key, value }, writer.uint32(66).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePolicy();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.apiVersion = reader.string();
                    break;
                case 2:
                    message.disabled = reader.bool();
                    break;
                case 3:
                    message.description = reader.string();
                    break;
                case 4:
                    message.metadata = exports.Metadata.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.policyType = {
                        $case: "resourcePolicy",
                        resourcePolicy: exports.ResourcePolicy.decode(reader, reader.uint32()),
                    };
                    break;
                case 6:
                    message.policyType = {
                        $case: "principalPolicy",
                        principalPolicy: exports.PrincipalPolicy.decode(reader, reader.uint32()),
                    };
                    break;
                case 7:
                    message.policyType = {
                        $case: "derivedRoles",
                        derivedRoles: exports.DerivedRoles.decode(reader, reader.uint32()),
                    };
                    break;
                case 8:
                    const entry8 = exports.Policy_VariablesEntry.decode(reader, reader.uint32());
                    if (entry8.value !== undefined) {
                        message.variables[entry8.key] = entry8.value;
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePolicy_VariablesEntry() {
    return { key: "", value: "" };
}
exports.Policy_VariablesEntry = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePolicy_VariablesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseMetadata() {
    return {
        sourceFile: "",
        annotations: {},
        hash: undefined,
        storeIdentifer: "",
    };
}
exports.Metadata = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.sourceFile !== "") {
            writer.uint32(10).string(message.sourceFile);
        }
        Object.entries(message.annotations).forEach(([key, value]) => {
            exports.Metadata_AnnotationsEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();
        });
        if (message.hash !== undefined) {
            wrappers_1.UInt64Value.encode({ value: message.hash }, writer.uint32(26).fork()).ldelim();
        }
        if (message.storeIdentifer !== "") {
            writer.uint32(34).string(message.storeIdentifer);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMetadata();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.sourceFile = reader.string();
                    break;
                case 2:
                    const entry2 = exports.Metadata_AnnotationsEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.annotations[entry2.key] = entry2.value;
                    }
                    break;
                case 3:
                    message.hash = wrappers_1.UInt64Value.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.storeIdentifer = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseMetadata_AnnotationsEntry() {
    return { key: "", value: "" };
}
exports.Metadata_AnnotationsEntry = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMetadata_AnnotationsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseResourcePolicy() {
    return {
        resource: "",
        version: "",
        importDerivedRoles: [],
        rules: [],
        scope: "",
        schemas: undefined,
    };
}
exports.ResourcePolicy = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.resource !== "") {
            writer.uint32(10).string(message.resource);
        }
        if (message.version !== "") {
            writer.uint32(18).string(message.version);
        }
        for (const v of message.importDerivedRoles) {
            writer.uint32(26).string(v);
        }
        for (const v of message.rules) {
            exports.ResourceRule.encode(v, writer.uint32(34).fork()).ldelim();
        }
        if (message.scope !== "") {
            writer.uint32(42).string(message.scope);
        }
        if (message.schemas !== undefined) {
            exports.Schemas.encode(message.schemas, writer.uint32(50).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseResourcePolicy();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.resource = reader.string();
                    break;
                case 2:
                    message.version = reader.string();
                    break;
                case 3:
                    message.importDerivedRoles.push(reader.string());
                    break;
                case 4:
                    message.rules.push(exports.ResourceRule.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.scope = reader.string();
                    break;
                case 6:
                    message.schemas = exports.Schemas.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseResourceRule() {
    return {
        actions: [],
        derivedRoles: [],
        roles: [],
        condition: undefined,
        effect: 0,
        name: "",
    };
}
exports.ResourceRule = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.actions) {
            writer.uint32(10).string(v);
        }
        for (const v of message.derivedRoles) {
            writer.uint32(18).string(v);
        }
        for (const v of message.roles) {
            writer.uint32(26).string(v);
        }
        if (message.condition !== undefined) {
            exports.Condition.encode(message.condition, writer.uint32(34).fork()).ldelim();
        }
        if (message.effect !== 0) {
            writer.uint32(40).int32(message.effect);
        }
        if (message.name !== "") {
            writer.uint32(50).string(message.name);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseResourceRule();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.actions.push(reader.string());
                    break;
                case 2:
                    message.derivedRoles.push(reader.string());
                    break;
                case 3:
                    message.roles.push(reader.string());
                    break;
                case 4:
                    message.condition = exports.Condition.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.effect = reader.int32();
                    break;
                case 6:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePrincipalPolicy() {
    return { principal: "", version: "", rules: [], scope: "" };
}
exports.PrincipalPolicy = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.principal !== "") {
            writer.uint32(10).string(message.principal);
        }
        if (message.version !== "") {
            writer.uint32(18).string(message.version);
        }
        for (const v of message.rules) {
            exports.PrincipalRule.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (message.scope !== "") {
            writer.uint32(34).string(message.scope);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePrincipalPolicy();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.principal = reader.string();
                    break;
                case 2:
                    message.version = reader.string();
                    break;
                case 3:
                    message.rules.push(exports.PrincipalRule.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.scope = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePrincipalRule() {
    return { resource: "", actions: [] };
}
exports.PrincipalRule = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.resource !== "") {
            writer.uint32(10).string(message.resource);
        }
        for (const v of message.actions) {
            exports.PrincipalRule_Action.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePrincipalRule();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.resource = reader.string();
                    break;
                case 2:
                    message.actions.push(exports.PrincipalRule_Action.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePrincipalRule_Action() {
    return { action: "", condition: undefined, effect: 0, name: "" };
}
exports.PrincipalRule_Action = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.action !== "") {
            writer.uint32(10).string(message.action);
        }
        if (message.condition !== undefined) {
            exports.Condition.encode(message.condition, writer.uint32(18).fork()).ldelim();
        }
        if (message.effect !== 0) {
            writer.uint32(24).int32(message.effect);
        }
        if (message.name !== "") {
            writer.uint32(34).string(message.name);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePrincipalRule_Action();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.action = reader.string();
                    break;
                case 2:
                    message.condition = exports.Condition.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.effect = reader.int32();
                    break;
                case 4:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseDerivedRoles() {
    return { name: "", definitions: [] };
}
exports.DerivedRoles = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        for (const v of message.definitions) {
            exports.RoleDef.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDerivedRoles();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.definitions.push(exports.RoleDef.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseRoleDef() {
    return { name: "", parentRoles: [], condition: undefined };
}
exports.RoleDef = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        for (const v of message.parentRoles) {
            writer.uint32(18).string(v);
        }
        if (message.condition !== undefined) {
            exports.Condition.encode(message.condition, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRoleDef();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.parentRoles.push(reader.string());
                    break;
                case 3:
                    message.condition = exports.Condition.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseCondition() {
    return { condition: undefined };
}
exports.Condition = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.condition?.$case === "match") {
            exports.Match.encode(message.condition.match, writer.uint32(10).fork()).ldelim();
        }
        if (message.condition?.$case === "script") {
            writer.uint32(18).string(message.condition.script);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCondition();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.condition = {
                        $case: "match",
                        match: exports.Match.decode(reader, reader.uint32()),
                    };
                    break;
                case 2:
                    message.condition = { $case: "script", script: reader.string() };
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseMatch() {
    return { op: undefined };
}
exports.Match = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.op?.$case === "all") {
            exports.Match_ExprList.encode(message.op.all, writer.uint32(10).fork()).ldelim();
        }
        if (message.op?.$case === "any") {
            exports.Match_ExprList.encode(message.op.any, writer.uint32(18).fork()).ldelim();
        }
        if (message.op?.$case === "none") {
            exports.Match_ExprList.encode(message.op.none, writer.uint32(26).fork()).ldelim();
        }
        if (message.op?.$case === "expr") {
            writer.uint32(34).string(message.op.expr);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMatch();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.op = {
                        $case: "all",
                        all: exports.Match_ExprList.decode(reader, reader.uint32()),
                    };
                    break;
                case 2:
                    message.op = {
                        $case: "any",
                        any: exports.Match_ExprList.decode(reader, reader.uint32()),
                    };
                    break;
                case 3:
                    message.op = {
                        $case: "none",
                        none: exports.Match_ExprList.decode(reader, reader.uint32()),
                    };
                    break;
                case 4:
                    message.op = { $case: "expr", expr: reader.string() };
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseMatch_ExprList() {
    return { of: [] };
}
exports.Match_ExprList = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.of) {
            exports.Match.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMatch_ExprList();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.of.push(exports.Match.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSchemas() {
    return { principalSchema: undefined, resourceSchema: undefined };
}
exports.Schemas = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.principalSchema !== undefined) {
            exports.Schemas_Schema.encode(message.principalSchema, writer.uint32(10).fork()).ldelim();
        }
        if (message.resourceSchema !== undefined) {
            exports.Schemas_Schema.encode(message.resourceSchema, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSchemas();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.principalSchema = exports.Schemas_Schema.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.resourceSchema = exports.Schemas_Schema.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSchemas_IgnoreWhen() {
    return { actions: [] };
}
exports.Schemas_IgnoreWhen = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.actions) {
            writer.uint32(10).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSchemas_IgnoreWhen();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.actions.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSchemas_Schema() {
    return { ref: "", ignoreWhen: undefined };
}
exports.Schemas_Schema = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.ref !== "") {
            writer.uint32(10).string(message.ref);
        }
        if (message.ignoreWhen !== undefined) {
            exports.Schemas_IgnoreWhen.encode(message.ignoreWhen, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSchemas_Schema();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.ref = reader.string();
                    break;
                case 2:
                    message.ignoreWhen = exports.Schemas_IgnoreWhen.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseTestFixture() {
    return {};
}
exports.TestFixture = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTestFixture();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseTestFixture_Principals() {
    return { principals: {} };
}
exports.TestFixture_Principals = {
    encode(message, writer = _m0.Writer.create()) {
        Object.entries(message.principals).forEach(([key, value]) => {
            exports.TestFixture_Principals_PrincipalsEntry.encode({ key: key, value }, writer.uint32(10).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTestFixture_Principals();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    const entry1 = exports.TestFixture_Principals_PrincipalsEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.principals[entry1.key] = entry1.value;
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseTestFixture_Principals_PrincipalsEntry() {
    return { key: "", value: undefined };
}
exports.TestFixture_Principals_PrincipalsEntry = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            engine_1.Principal.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTestFixture_Principals_PrincipalsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = engine_1.Principal.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseTestFixture_Resources() {
    return { resources: {} };
}
exports.TestFixture_Resources = {
    encode(message, writer = _m0.Writer.create()) {
        Object.entries(message.resources).forEach(([key, value]) => {
            exports.TestFixture_Resources_ResourcesEntry.encode({ key: key, value }, writer.uint32(10).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTestFixture_Resources();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    const entry1 = exports.TestFixture_Resources_ResourcesEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.resources[entry1.key] = entry1.value;
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseTestFixture_Resources_ResourcesEntry() {
    return { key: "", value: undefined };
}
exports.TestFixture_Resources_ResourcesEntry = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            engine_1.Resource.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTestFixture_Resources_ResourcesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = engine_1.Resource.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseTestFixture_AuxData() {
    return { auxData: {} };
}
exports.TestFixture_AuxData = {
    encode(message, writer = _m0.Writer.create()) {
        Object.entries(message.auxData).forEach(([key, value]) => {
            exports.TestFixture_AuxData_AuxDataEntry.encode({ key: key, value }, writer.uint32(10).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTestFixture_AuxData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    const entry1 = exports.TestFixture_AuxData_AuxDataEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.auxData[entry1.key] = entry1.value;
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseTestFixture_AuxData_AuxDataEntry() {
    return { key: "", value: undefined };
}
exports.TestFixture_AuxData_AuxDataEntry = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            engine_1.AuxData.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTestFixture_AuxData_AuxDataEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = engine_1.AuxData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseTestSuite() {
    return {
        name: "",
        description: "",
        skip: false,
        skipReason: "",
        tests: [],
        principals: {},
        resources: {},
        auxData: {},
    };
}
exports.TestSuite = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.description !== "") {
            writer.uint32(18).string(message.description);
        }
        if (message.skip === true) {
            writer.uint32(24).bool(message.skip);
        }
        if (message.skipReason !== "") {
            writer.uint32(34).string(message.skipReason);
        }
        for (const v of message.tests) {
            exports.TestTable.encode(v, writer.uint32(42).fork()).ldelim();
        }
        Object.entries(message.principals).forEach(([key, value]) => {
            exports.TestSuite_PrincipalsEntry.encode({ key: key, value }, writer.uint32(50).fork()).ldelim();
        });
        Object.entries(message.resources).forEach(([key, value]) => {
            exports.TestSuite_ResourcesEntry.encode({ key: key, value }, writer.uint32(58).fork()).ldelim();
        });
        Object.entries(message.auxData).forEach(([key, value]) => {
            exports.TestSuite_AuxDataEntry.encode({ key: key, value }, writer.uint32(66).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTestSuite();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.description = reader.string();
                    break;
                case 3:
                    message.skip = reader.bool();
                    break;
                case 4:
                    message.skipReason = reader.string();
                    break;
                case 5:
                    message.tests.push(exports.TestTable.decode(reader, reader.uint32()));
                    break;
                case 6:
                    const entry6 = exports.TestSuite_PrincipalsEntry.decode(reader, reader.uint32());
                    if (entry6.value !== undefined) {
                        message.principals[entry6.key] = entry6.value;
                    }
                    break;
                case 7:
                    const entry7 = exports.TestSuite_ResourcesEntry.decode(reader, reader.uint32());
                    if (entry7.value !== undefined) {
                        message.resources[entry7.key] = entry7.value;
                    }
                    break;
                case 8:
                    const entry8 = exports.TestSuite_AuxDataEntry.decode(reader, reader.uint32());
                    if (entry8.value !== undefined) {
                        message.auxData[entry8.key] = entry8.value;
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseTestSuite_PrincipalsEntry() {
    return { key: "", value: undefined };
}
exports.TestSuite_PrincipalsEntry = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            engine_1.Principal.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTestSuite_PrincipalsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = engine_1.Principal.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseTestSuite_ResourcesEntry() {
    return { key: "", value: undefined };
}
exports.TestSuite_ResourcesEntry = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            engine_1.Resource.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTestSuite_ResourcesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = engine_1.Resource.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseTestSuite_AuxDataEntry() {
    return { key: "", value: undefined };
}
exports.TestSuite_AuxDataEntry = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            engine_1.AuxData.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTestSuite_AuxDataEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = engine_1.AuxData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseTestTable() {
    return {
        name: "",
        description: "",
        skip: false,
        skipReason: "",
        input: undefined,
        expected: [],
    };
}
exports.TestTable = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.description !== "") {
            writer.uint32(18).string(message.description);
        }
        if (message.skip === true) {
            writer.uint32(24).bool(message.skip);
        }
        if (message.skipReason !== "") {
            writer.uint32(34).string(message.skipReason);
        }
        if (message.input !== undefined) {
            exports.TestTable_Input.encode(message.input, writer.uint32(42).fork()).ldelim();
        }
        for (const v of message.expected) {
            exports.TestTable_Expectation.encode(v, writer.uint32(50).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTestTable();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.description = reader.string();
                    break;
                case 3:
                    message.skip = reader.bool();
                    break;
                case 4:
                    message.skipReason = reader.string();
                    break;
                case 5:
                    message.input = exports.TestTable_Input.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.expected.push(exports.TestTable_Expectation.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseTestTable_Input() {
    return { principals: [], resources: [], actions: [], auxData: "" };
}
exports.TestTable_Input = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.principals) {
            writer.uint32(10).string(v);
        }
        for (const v of message.resources) {
            writer.uint32(18).string(v);
        }
        for (const v of message.actions) {
            writer.uint32(26).string(v);
        }
        if (message.auxData !== "") {
            writer.uint32(34).string(message.auxData);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTestTable_Input();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.principals.push(reader.string());
                    break;
                case 2:
                    message.resources.push(reader.string());
                    break;
                case 3:
                    message.actions.push(reader.string());
                    break;
                case 4:
                    message.auxData = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseTestTable_Expectation() {
    return { principal: "", resource: "", actions: {} };
}
exports.TestTable_Expectation = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.principal !== "") {
            writer.uint32(10).string(message.principal);
        }
        if (message.resource !== "") {
            writer.uint32(18).string(message.resource);
        }
        Object.entries(message.actions).forEach(([key, value]) => {
            exports.TestTable_Expectation_ActionsEntry.encode({ key: key, value }, writer.uint32(26).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTestTable_Expectation();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.principal = reader.string();
                    break;
                case 2:
                    message.resource = reader.string();
                    break;
                case 3:
                    const entry3 = exports.TestTable_Expectation_ActionsEntry.decode(reader, reader.uint32());
                    if (entry3.value !== undefined) {
                        message.actions[entry3.key] = entry3.value;
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseTestTable_Expectation_ActionsEntry() {
    return { key: "", value: 0 };
}
exports.TestTable_Expectation_ActionsEntry = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== 0) {
            writer.uint32(16).int32(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTestTable_Expectation_ActionsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseTest() {
    return {
        name: undefined,
        description: "",
        skip: false,
        skipReason: "",
        input: undefined,
        expected: {},
    };
}
exports.Test = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.name !== undefined) {
            exports.Test_TestName.encode(message.name, writer.uint32(10).fork()).ldelim();
        }
        if (message.description !== "") {
            writer.uint32(18).string(message.description);
        }
        if (message.skip === true) {
            writer.uint32(24).bool(message.skip);
        }
        if (message.skipReason !== "") {
            writer.uint32(34).string(message.skipReason);
        }
        if (message.input !== undefined) {
            engine_1.CheckInput.encode(message.input, writer.uint32(42).fork()).ldelim();
        }
        Object.entries(message.expected).forEach(([key, value]) => {
            exports.Test_ExpectedEntry.encode({ key: key, value }, writer.uint32(50).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.name = exports.Test_TestName.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.description = reader.string();
                    break;
                case 3:
                    message.skip = reader.bool();
                    break;
                case 4:
                    message.skipReason = reader.string();
                    break;
                case 5:
                    message.input = engine_1.CheckInput.decode(reader, reader.uint32());
                    break;
                case 6:
                    const entry6 = exports.Test_ExpectedEntry.decode(reader, reader.uint32());
                    if (entry6.value !== undefined) {
                        message.expected[entry6.key] = entry6.value;
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseTest_TestName() {
    return { testTableName: "", principalKey: "", resourceKey: "" };
}
exports.Test_TestName = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.testTableName !== "") {
            writer.uint32(10).string(message.testTableName);
        }
        if (message.principalKey !== "") {
            writer.uint32(18).string(message.principalKey);
        }
        if (message.resourceKey !== "") {
            writer.uint32(26).string(message.resourceKey);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTest_TestName();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.testTableName = reader.string();
                    break;
                case 2:
                    message.principalKey = reader.string();
                    break;
                case 3:
                    message.resourceKey = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseTest_ExpectedEntry() {
    return { key: "", value: 0 };
}
exports.Test_ExpectedEntry = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== 0) {
            writer.uint32(16).int32(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTest_ExpectedEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseTestResults() {
    return { suites: [], summary: undefined };
}
exports.TestResults = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.suites) {
            exports.TestResults_Suite.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.summary !== undefined) {
            exports.TestResults_Summary.encode(message.summary, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTestResults();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.suites.push(exports.TestResults_Suite.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.summary = exports.TestResults_Summary.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseTestResults_Tally() {
    return { result: 0, count: 0 };
}
exports.TestResults_Tally = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.result !== 0) {
            writer.uint32(8).int32(message.result);
        }
        if (message.count !== 0) {
            writer.uint32(16).uint32(message.count);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTestResults_Tally();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    message.count = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseTestResults_Summary() {
    return { overallResult: 0, testsCount: 0, resultCounts: [] };
}
exports.TestResults_Summary = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.overallResult !== 0) {
            writer.uint32(8).int32(message.overallResult);
        }
        if (message.testsCount !== 0) {
            writer.uint32(16).uint32(message.testsCount);
        }
        for (const v of message.resultCounts) {
            exports.TestResults_Tally.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTestResults_Summary();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.overallResult = reader.int32();
                    break;
                case 2:
                    message.testsCount = reader.uint32();
                    break;
                case 3:
                    message.resultCounts.push(exports.TestResults_Tally.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseTestResults_Suite() {
    return { file: "", name: "", principals: [], summary: undefined, error: "" };
}
exports.TestResults_Suite = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.file !== "") {
            writer.uint32(10).string(message.file);
        }
        if (message.name !== "") {
            writer.uint32(18).string(message.name);
        }
        for (const v of message.principals) {
            exports.TestResults_Principal.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (message.summary !== undefined) {
            exports.TestResults_Summary.encode(message.summary, writer.uint32(34).fork()).ldelim();
        }
        if (message.error !== "") {
            writer.uint32(42).string(message.error);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTestResults_Suite();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.file = reader.string();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.principals.push(exports.TestResults_Principal.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.summary = exports.TestResults_Summary.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.error = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseTestResults_Principal() {
    return { name: "", resources: [] };
}
exports.TestResults_Principal = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        for (const v of message.resources) {
            exports.TestResults_Resource.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTestResults_Principal();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.resources.push(exports.TestResults_Resource.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseTestResults_Resource() {
    return { name: "", actions: [] };
}
exports.TestResults_Resource = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        for (const v of message.actions) {
            exports.TestResults_Action.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTestResults_Resource();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.actions.push(exports.TestResults_Action.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseTestResults_Action() {
    return { name: "", details: undefined };
}
exports.TestResults_Action = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.details !== undefined) {
            exports.TestResults_Details.encode(message.details, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTestResults_Action();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.details = exports.TestResults_Details.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseTestResults_Details() {
    return { result: 0, outcome: undefined, engineTrace: [] };
}
exports.TestResults_Details = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.result !== 0) {
            writer.uint32(8).int32(message.result);
        }
        if (message.outcome?.$case === "failure") {
            exports.TestResults_Failure.encode(message.outcome.failure, writer.uint32(18).fork()).ldelim();
        }
        if (message.outcome?.$case === "error") {
            writer.uint32(26).string(message.outcome.error);
        }
        for (const v of message.engineTrace) {
            engine_1.Trace.encode(v, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTestResults_Details();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    message.outcome = {
                        $case: "failure",
                        failure: exports.TestResults_Failure.decode(reader, reader.uint32()),
                    };
                    break;
                case 3:
                    message.outcome = { $case: "error", error: reader.string() };
                    break;
                case 4:
                    message.engineTrace.push(engine_1.Trace.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseTestResults_Failure() {
    return { expected: 0, actual: 0 };
}
exports.TestResults_Failure = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.expected !== 0) {
            writer.uint32(8).int32(message.expected);
        }
        if (message.actual !== 0) {
            writer.uint32(16).int32(message.actual);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTestResults_Failure();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.expected = reader.int32();
                    break;
                case 2:
                    message.actual = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
//# sourceMappingURL=policy.js.map