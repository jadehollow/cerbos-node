"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReloadStoreRequest = exports.DeleteSchemaRequest = exports.GetSchemaRequest = exports.ListSchemasRequest = exports.AddOrUpdateSchemaRequest = exports.GetPolicyRequest = exports.ListPoliciesRequest = exports.ServerInfoRequest = exports.ListAuditLogEntriesRequest_TimeRange = exports.ListAuditLogEntriesRequest = exports.AddOrUpdatePolicyRequest = exports.PlaygroundProxyRequest = exports.PlaygroundEvaluateRequest = exports.PlaygroundTestRequest = exports.PlaygroundValidateRequest = exports.File = exports.AuxData_JWT = exports.AuxData = exports.CheckResourcesRequest_ResourceEntry = exports.CheckResourcesRequest = exports.CheckResourceBatchRequest_BatchEntry = exports.CheckResourceBatchRequest = exports.AttributesMap_AttrEntry = exports.AttributesMap = exports.ResourceSet_InstancesEntry = exports.ResourceSet = exports.CheckResourceSetRequest = exports.PlanResourcesRequest = exports.ListAuditLogEntriesRequest_Kind = exports.protobufPackage = void 0;
/* eslint-disable */
const timestamp_1 = require("../../../google/protobuf/timestamp");
const engine_1 = require("../../../cerbos/engine/v1/engine");
const policy_1 = require("../../../cerbos/policy/v1/policy");
const schema_1 = require("../../../cerbos/schema/v1/schema");
const duration_1 = require("../../../google/protobuf/duration");
const _m0 = __importStar(require("protobufjs/minimal"));
const struct_1 = require("../../../google/protobuf/struct");
exports.protobufPackage = "cerbos.request.v1";
var ListAuditLogEntriesRequest_Kind;
(function (ListAuditLogEntriesRequest_Kind) {
    ListAuditLogEntriesRequest_Kind[ListAuditLogEntriesRequest_Kind["KIND_UNSPECIFIED"] = 0] = "KIND_UNSPECIFIED";
    ListAuditLogEntriesRequest_Kind[ListAuditLogEntriesRequest_Kind["KIND_ACCESS"] = 1] = "KIND_ACCESS";
    ListAuditLogEntriesRequest_Kind[ListAuditLogEntriesRequest_Kind["KIND_DECISION"] = 2] = "KIND_DECISION";
})(ListAuditLogEntriesRequest_Kind = exports.ListAuditLogEntriesRequest_Kind || (exports.ListAuditLogEntriesRequest_Kind = {}));
function createBasePlanResourcesRequest() {
    return {
        requestId: "",
        action: "",
        principal: undefined,
        resource: undefined,
        auxData: undefined,
        includeMeta: false,
    };
}
exports.PlanResourcesRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.requestId !== "") {
            writer.uint32(10).string(message.requestId);
        }
        if (message.action !== "") {
            writer.uint32(18).string(message.action);
        }
        if (message.principal !== undefined) {
            engine_1.Principal.encode(message.principal, writer.uint32(26).fork()).ldelim();
        }
        if (message.resource !== undefined) {
            engine_1.PlanResourcesInput_Resource.encode(message.resource, writer.uint32(34).fork()).ldelim();
        }
        if (message.auxData !== undefined) {
            exports.AuxData.encode(message.auxData, writer.uint32(42).fork()).ldelim();
        }
        if (message.includeMeta === true) {
            writer.uint32(48).bool(message.includeMeta);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlanResourcesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.requestId = reader.string();
                    break;
                case 2:
                    message.action = reader.string();
                    break;
                case 3:
                    message.principal = engine_1.Principal.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.resource = engine_1.PlanResourcesInput_Resource.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.auxData = exports.AuxData.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.includeMeta = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseCheckResourceSetRequest() {
    return {
        requestId: "",
        actions: [],
        principal: undefined,
        resource: undefined,
        includeMeta: false,
        auxData: undefined,
    };
}
exports.CheckResourceSetRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.requestId !== "") {
            writer.uint32(10).string(message.requestId);
        }
        for (const v of message.actions) {
            writer.uint32(18).string(v);
        }
        if (message.principal !== undefined) {
            engine_1.Principal.encode(message.principal, writer.uint32(26).fork()).ldelim();
        }
        if (message.resource !== undefined) {
            exports.ResourceSet.encode(message.resource, writer.uint32(34).fork()).ldelim();
        }
        if (message.includeMeta === true) {
            writer.uint32(40).bool(message.includeMeta);
        }
        if (message.auxData !== undefined) {
            exports.AuxData.encode(message.auxData, writer.uint32(50).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCheckResourceSetRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.requestId = reader.string();
                    break;
                case 2:
                    message.actions.push(reader.string());
                    break;
                case 3:
                    message.principal = engine_1.Principal.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.resource = exports.ResourceSet.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.includeMeta = reader.bool();
                    break;
                case 6:
                    message.auxData = exports.AuxData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseResourceSet() {
    return { kind: "", policyVersion: "", instances: {}, scope: "" };
}
exports.ResourceSet = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.kind !== "") {
            writer.uint32(10).string(message.kind);
        }
        if (message.policyVersion !== "") {
            writer.uint32(18).string(message.policyVersion);
        }
        Object.entries(message.instances).forEach(([key, value]) => {
            exports.ResourceSet_InstancesEntry.encode({ key: key, value }, writer.uint32(26).fork()).ldelim();
        });
        if (message.scope !== "") {
            writer.uint32(34).string(message.scope);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseResourceSet();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.kind = reader.string();
                    break;
                case 2:
                    message.policyVersion = reader.string();
                    break;
                case 3:
                    const entry3 = exports.ResourceSet_InstancesEntry.decode(reader, reader.uint32());
                    if (entry3.value !== undefined) {
                        message.instances[entry3.key] = entry3.value;
                    }
                    break;
                case 4:
                    message.scope = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseResourceSet_InstancesEntry() {
    return { key: "", value: undefined };
}
exports.ResourceSet_InstancesEntry = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            exports.AttributesMap.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseResourceSet_InstancesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = exports.AttributesMap.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseAttributesMap() {
    return { attr: {} };
}
exports.AttributesMap = {
    encode(message, writer = _m0.Writer.create()) {
        Object.entries(message.attr).forEach(([key, value]) => {
            if (value !== undefined) {
                exports.AttributesMap_AttrEntry.encode({ key: key, value }, writer.uint32(10).fork()).ldelim();
            }
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAttributesMap();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    const entry1 = exports.AttributesMap_AttrEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.attr[entry1.key] = entry1.value;
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseAttributesMap_AttrEntry() {
    return { key: "", value: undefined };
}
exports.AttributesMap_AttrEntry = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            struct_1.Value.encode(struct_1.Value.wrap(message.value), writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAttributesMap_AttrEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = struct_1.Value.unwrap(struct_1.Value.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseCheckResourceBatchRequest() {
    return {
        requestId: "",
        principal: undefined,
        resources: [],
        auxData: undefined,
    };
}
exports.CheckResourceBatchRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.requestId !== "") {
            writer.uint32(10).string(message.requestId);
        }
        if (message.principal !== undefined) {
            engine_1.Principal.encode(message.principal, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.resources) {
            exports.CheckResourceBatchRequest_BatchEntry.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (message.auxData !== undefined) {
            exports.AuxData.encode(message.auxData, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCheckResourceBatchRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.requestId = reader.string();
                    break;
                case 2:
                    message.principal = engine_1.Principal.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.resources.push(exports.CheckResourceBatchRequest_BatchEntry.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.auxData = exports.AuxData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseCheckResourceBatchRequest_BatchEntry() {
    return { actions: [], resource: undefined };
}
exports.CheckResourceBatchRequest_BatchEntry = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.actions) {
            writer.uint32(10).string(v);
        }
        if (message.resource !== undefined) {
            engine_1.Resource.encode(message.resource, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCheckResourceBatchRequest_BatchEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.actions.push(reader.string());
                    break;
                case 2:
                    message.resource = engine_1.Resource.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseCheckResourcesRequest() {
    return {
        requestId: "",
        includeMeta: false,
        principal: undefined,
        resources: [],
        auxData: undefined,
    };
}
exports.CheckResourcesRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.requestId !== "") {
            writer.uint32(10).string(message.requestId);
        }
        if (message.includeMeta === true) {
            writer.uint32(16).bool(message.includeMeta);
        }
        if (message.principal !== undefined) {
            engine_1.Principal.encode(message.principal, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.resources) {
            exports.CheckResourcesRequest_ResourceEntry.encode(v, writer.uint32(34).fork()).ldelim();
        }
        if (message.auxData !== undefined) {
            exports.AuxData.encode(message.auxData, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCheckResourcesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.requestId = reader.string();
                    break;
                case 2:
                    message.includeMeta = reader.bool();
                    break;
                case 3:
                    message.principal = engine_1.Principal.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.resources.push(exports.CheckResourcesRequest_ResourceEntry.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.auxData = exports.AuxData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseCheckResourcesRequest_ResourceEntry() {
    return { actions: [], resource: undefined };
}
exports.CheckResourcesRequest_ResourceEntry = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.actions) {
            writer.uint32(10).string(v);
        }
        if (message.resource !== undefined) {
            engine_1.Resource.encode(message.resource, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCheckResourcesRequest_ResourceEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.actions.push(reader.string());
                    break;
                case 2:
                    message.resource = engine_1.Resource.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseAuxData() {
    return { jwt: undefined };
}
exports.AuxData = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.jwt !== undefined) {
            exports.AuxData_JWT.encode(message.jwt, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAuxData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.jwt = exports.AuxData_JWT.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseAuxData_JWT() {
    return { token: "", keySetId: "" };
}
exports.AuxData_JWT = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.token !== "") {
            writer.uint32(10).string(message.token);
        }
        if (message.keySetId !== "") {
            writer.uint32(18).string(message.keySetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAuxData_JWT();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.token = reader.string();
                    break;
                case 2:
                    message.keySetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseFile() {
    return { fileName: "", contents: Buffer.alloc(0) };
}
exports.File = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.fileName !== "") {
            writer.uint32(10).string(message.fileName);
        }
        if (message.contents.length !== 0) {
            writer.uint32(18).bytes(message.contents);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFile();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.fileName = reader.string();
                    break;
                case 2:
                    message.contents = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlaygroundValidateRequest() {
    return { playgroundId: "", files: [] };
}
exports.PlaygroundValidateRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.playgroundId !== "") {
            writer.uint32(10).string(message.playgroundId);
        }
        for (const v of message.files) {
            exports.File.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlaygroundValidateRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.playgroundId = reader.string();
                    break;
                case 2:
                    message.files.push(exports.File.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlaygroundTestRequest() {
    return { playgroundId: "", files: [] };
}
exports.PlaygroundTestRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.playgroundId !== "") {
            writer.uint32(10).string(message.playgroundId);
        }
        for (const v of message.files) {
            exports.File.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlaygroundTestRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.playgroundId = reader.string();
                    break;
                case 2:
                    message.files.push(exports.File.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlaygroundEvaluateRequest() {
    return {
        playgroundId: "",
        files: [],
        principal: undefined,
        resource: undefined,
        actions: [],
        auxData: undefined,
    };
}
exports.PlaygroundEvaluateRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.playgroundId !== "") {
            writer.uint32(10).string(message.playgroundId);
        }
        for (const v of message.files) {
            exports.File.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.principal !== undefined) {
            engine_1.Principal.encode(message.principal, writer.uint32(26).fork()).ldelim();
        }
        if (message.resource !== undefined) {
            engine_1.Resource.encode(message.resource, writer.uint32(34).fork()).ldelim();
        }
        for (const v of message.actions) {
            writer.uint32(42).string(v);
        }
        if (message.auxData !== undefined) {
            exports.AuxData.encode(message.auxData, writer.uint32(50).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlaygroundEvaluateRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.playgroundId = reader.string();
                    break;
                case 2:
                    message.files.push(exports.File.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.principal = engine_1.Principal.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.resource = engine_1.Resource.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.actions.push(reader.string());
                    break;
                case 6:
                    message.auxData = exports.AuxData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBasePlaygroundProxyRequest() {
    return { playgroundId: "", files: [], proxyRequest: undefined };
}
exports.PlaygroundProxyRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.playgroundId !== "") {
            writer.uint32(10).string(message.playgroundId);
        }
        for (const v of message.files) {
            exports.File.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.proxyRequest?.$case === "checkResourceSet") {
            exports.CheckResourceSetRequest.encode(message.proxyRequest.checkResourceSet, writer.uint32(26).fork()).ldelim();
        }
        if (message.proxyRequest?.$case === "checkResourceBatch") {
            exports.CheckResourceBatchRequest.encode(message.proxyRequest.checkResourceBatch, writer.uint32(34).fork()).ldelim();
        }
        if (message.proxyRequest?.$case === "planResources") {
            exports.PlanResourcesRequest.encode(message.proxyRequest.planResources, writer.uint32(42).fork()).ldelim();
        }
        if (message.proxyRequest?.$case === "checkResources") {
            exports.CheckResourcesRequest.encode(message.proxyRequest.checkResources, writer.uint32(50).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlaygroundProxyRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.playgroundId = reader.string();
                    break;
                case 2:
                    message.files.push(exports.File.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.proxyRequest = {
                        $case: "checkResourceSet",
                        checkResourceSet: exports.CheckResourceSetRequest.decode(reader, reader.uint32()),
                    };
                    break;
                case 4:
                    message.proxyRequest = {
                        $case: "checkResourceBatch",
                        checkResourceBatch: exports.CheckResourceBatchRequest.decode(reader, reader.uint32()),
                    };
                    break;
                case 5:
                    message.proxyRequest = {
                        $case: "planResources",
                        planResources: exports.PlanResourcesRequest.decode(reader, reader.uint32()),
                    };
                    break;
                case 6:
                    message.proxyRequest = {
                        $case: "checkResources",
                        checkResources: exports.CheckResourcesRequest.decode(reader, reader.uint32()),
                    };
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseAddOrUpdatePolicyRequest() {
    return { policies: [] };
}
exports.AddOrUpdatePolicyRequest = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.policies) {
            policy_1.Policy.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAddOrUpdatePolicyRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.policies.push(policy_1.Policy.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseListAuditLogEntriesRequest() {
    return { kind: 0, filter: undefined };
}
exports.ListAuditLogEntriesRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.kind !== 0) {
            writer.uint32(8).int32(message.kind);
        }
        if (message.filter?.$case === "tail") {
            writer.uint32(16).uint32(message.filter.tail);
        }
        if (message.filter?.$case === "between") {
            exports.ListAuditLogEntriesRequest_TimeRange.encode(message.filter.between, writer.uint32(26).fork()).ldelim();
        }
        if (message.filter?.$case === "since") {
            duration_1.Duration.encode(message.filter.since, writer.uint32(34).fork()).ldelim();
        }
        if (message.filter?.$case === "lookup") {
            writer.uint32(42).string(message.filter.lookup);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseListAuditLogEntriesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.kind = reader.int32();
                    break;
                case 2:
                    message.filter = { $case: "tail", tail: reader.uint32() };
                    break;
                case 3:
                    message.filter = {
                        $case: "between",
                        between: exports.ListAuditLogEntriesRequest_TimeRange.decode(reader, reader.uint32()),
                    };
                    break;
                case 4:
                    message.filter = {
                        $case: "since",
                        since: duration_1.Duration.decode(reader, reader.uint32()),
                    };
                    break;
                case 5:
                    message.filter = { $case: "lookup", lookup: reader.string() };
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseListAuditLogEntriesRequest_TimeRange() {
    return { start: undefined, end: undefined };
}
exports.ListAuditLogEntriesRequest_TimeRange = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.start !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.start), writer.uint32(10).fork()).ldelim();
        }
        if (message.end !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.end), writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseListAuditLogEntriesRequest_TimeRange();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.start = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.end = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseServerInfoRequest() {
    return {};
}
exports.ServerInfoRequest = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseServerInfoRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseListPoliciesRequest() {
    return {};
}
exports.ListPoliciesRequest = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseListPoliciesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseGetPolicyRequest() {
    return { id: [] };
}
exports.GetPolicyRequest = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.id) {
            writer.uint32(10).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetPolicyRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseAddOrUpdateSchemaRequest() {
    return { schemas: [] };
}
exports.AddOrUpdateSchemaRequest = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.schemas) {
            schema_1.Schema.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAddOrUpdateSchemaRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.schemas.push(schema_1.Schema.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseListSchemasRequest() {
    return {};
}
exports.ListSchemasRequest = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseListSchemasRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseGetSchemaRequest() {
    return { id: [] };
}
exports.GetSchemaRequest = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.id) {
            writer.uint32(10).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetSchemaRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseDeleteSchemaRequest() {
    return { id: [] };
}
exports.DeleteSchemaRequest = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.id) {
            writer.uint32(10).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDeleteSchemaRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseReloadStoreRequest() {
    return { wait: false };
}
exports.ReloadStoreRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.wait === true) {
            writer.uint32(8).bool(message.wait);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseReloadStoreRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.wait = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function toTimestamp(date) {
    const seconds = date.getTime() / 1000;
    const nanos = (date.getTime() % 1000) * 1000000;
    return { seconds, nanos };
}
function fromTimestamp(t) {
    let millis = t.seconds * 1000;
    millis += t.nanos / 1000000;
    return new Date(millis);
}
//# sourceMappingURL=request.js.map