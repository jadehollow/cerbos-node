"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Scopes_ScopeEntry = exports.Scopes = exports.SecurityRequirement_SecurityRequirementEntry = exports.SecurityRequirement_SecurityRequirementValue = exports.SecurityRequirement = exports.SecurityScheme_ExtensionsEntry = exports.SecurityScheme = exports.SecurityDefinitions_SecurityEntry = exports.SecurityDefinitions = exports.Tag = exports.JSONSchema = exports.Schema = exports.ExternalDocumentation = exports.License = exports.Contact = exports.Info_ExtensionsEntry = exports.Info = exports.Response_ExtensionsEntry = exports.Response_ExamplesEntry = exports.Response_HeadersEntry = exports.Response = exports.Header = exports.Operation_ExtensionsEntry = exports.Operation_ResponsesEntry = exports.Operation = exports.Swagger_ExtensionsEntry = exports.Swagger_ResponsesEntry = exports.Swagger = exports.SecurityScheme_Flow = exports.SecurityScheme_In = exports.SecurityScheme_Type = exports.JSONSchema_JSONSchemaSimpleTypes = exports.Scheme = exports.protobufPackage = void 0;
/* eslint-disable */
const long_1 = __importDefault(require("long"));
const _m0 = __importStar(require("protobufjs/minimal"));
const struct_1 = require("../../google/protobuf/struct");
exports.protobufPackage = "grpc.gateway.protoc_gen_openapiv2.options";
/**
 * Scheme describes the schemes supported by the OpenAPI Swagger
 * and Operation objects.
 */
var Scheme;
(function (Scheme) {
    Scheme[Scheme["UNKNOWN"] = 0] = "UNKNOWN";
    Scheme[Scheme["HTTP"] = 1] = "HTTP";
    Scheme[Scheme["HTTPS"] = 2] = "HTTPS";
    Scheme[Scheme["WS"] = 3] = "WS";
    Scheme[Scheme["WSS"] = 4] = "WSS";
})(Scheme = exports.Scheme || (exports.Scheme = {}));
var JSONSchema_JSONSchemaSimpleTypes;
(function (JSONSchema_JSONSchemaSimpleTypes) {
    JSONSchema_JSONSchemaSimpleTypes[JSONSchema_JSONSchemaSimpleTypes["UNKNOWN"] = 0] = "UNKNOWN";
    JSONSchema_JSONSchemaSimpleTypes[JSONSchema_JSONSchemaSimpleTypes["ARRAY"] = 1] = "ARRAY";
    JSONSchema_JSONSchemaSimpleTypes[JSONSchema_JSONSchemaSimpleTypes["BOOLEAN"] = 2] = "BOOLEAN";
    JSONSchema_JSONSchemaSimpleTypes[JSONSchema_JSONSchemaSimpleTypes["INTEGER"] = 3] = "INTEGER";
    JSONSchema_JSONSchemaSimpleTypes[JSONSchema_JSONSchemaSimpleTypes["NULL"] = 4] = "NULL";
    JSONSchema_JSONSchemaSimpleTypes[JSONSchema_JSONSchemaSimpleTypes["NUMBER"] = 5] = "NUMBER";
    JSONSchema_JSONSchemaSimpleTypes[JSONSchema_JSONSchemaSimpleTypes["OBJECT"] = 6] = "OBJECT";
    JSONSchema_JSONSchemaSimpleTypes[JSONSchema_JSONSchemaSimpleTypes["STRING"] = 7] = "STRING";
})(JSONSchema_JSONSchemaSimpleTypes = exports.JSONSchema_JSONSchemaSimpleTypes || (exports.JSONSchema_JSONSchemaSimpleTypes = {}));
/**
 * The type of the security scheme. Valid values are "basic",
 * "apiKey" or "oauth2".
 */
var SecurityScheme_Type;
(function (SecurityScheme_Type) {
    SecurityScheme_Type[SecurityScheme_Type["TYPE_INVALID"] = 0] = "TYPE_INVALID";
    SecurityScheme_Type[SecurityScheme_Type["TYPE_BASIC"] = 1] = "TYPE_BASIC";
    SecurityScheme_Type[SecurityScheme_Type["TYPE_API_KEY"] = 2] = "TYPE_API_KEY";
    SecurityScheme_Type[SecurityScheme_Type["TYPE_OAUTH2"] = 3] = "TYPE_OAUTH2";
})(SecurityScheme_Type = exports.SecurityScheme_Type || (exports.SecurityScheme_Type = {}));
/** The location of the API key. Valid values are "query" or "header". */
var SecurityScheme_In;
(function (SecurityScheme_In) {
    SecurityScheme_In[SecurityScheme_In["IN_INVALID"] = 0] = "IN_INVALID";
    SecurityScheme_In[SecurityScheme_In["IN_QUERY"] = 1] = "IN_QUERY";
    SecurityScheme_In[SecurityScheme_In["IN_HEADER"] = 2] = "IN_HEADER";
})(SecurityScheme_In = exports.SecurityScheme_In || (exports.SecurityScheme_In = {}));
/**
 * The flow used by the OAuth2 security scheme. Valid values are
 * "implicit", "password", "application" or "accessCode".
 */
var SecurityScheme_Flow;
(function (SecurityScheme_Flow) {
    SecurityScheme_Flow[SecurityScheme_Flow["FLOW_INVALID"] = 0] = "FLOW_INVALID";
    SecurityScheme_Flow[SecurityScheme_Flow["FLOW_IMPLICIT"] = 1] = "FLOW_IMPLICIT";
    SecurityScheme_Flow[SecurityScheme_Flow["FLOW_PASSWORD"] = 2] = "FLOW_PASSWORD";
    SecurityScheme_Flow[SecurityScheme_Flow["FLOW_APPLICATION"] = 3] = "FLOW_APPLICATION";
    SecurityScheme_Flow[SecurityScheme_Flow["FLOW_ACCESS_CODE"] = 4] = "FLOW_ACCESS_CODE";
})(SecurityScheme_Flow = exports.SecurityScheme_Flow || (exports.SecurityScheme_Flow = {}));
function createBaseSwagger() {
    return {
        swagger: "",
        info: undefined,
        host: "",
        basePath: "",
        schemes: [],
        consumes: [],
        produces: [],
        responses: {},
        securityDefinitions: undefined,
        security: [],
        externalDocs: undefined,
        extensions: {},
    };
}
exports.Swagger = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.swagger !== "") {
            writer.uint32(10).string(message.swagger);
        }
        if (message.info !== undefined) {
            exports.Info.encode(message.info, writer.uint32(18).fork()).ldelim();
        }
        if (message.host !== "") {
            writer.uint32(26).string(message.host);
        }
        if (message.basePath !== "") {
            writer.uint32(34).string(message.basePath);
        }
        writer.uint32(42).fork();
        for (const v of message.schemes) {
            writer.int32(v);
        }
        writer.ldelim();
        for (const v of message.consumes) {
            writer.uint32(50).string(v);
        }
        for (const v of message.produces) {
            writer.uint32(58).string(v);
        }
        Object.entries(message.responses).forEach(([key, value]) => {
            exports.Swagger_ResponsesEntry.encode({ key: key, value }, writer.uint32(82).fork()).ldelim();
        });
        if (message.securityDefinitions !== undefined) {
            exports.SecurityDefinitions.encode(message.securityDefinitions, writer.uint32(90).fork()).ldelim();
        }
        for (const v of message.security) {
            exports.SecurityRequirement.encode(v, writer.uint32(98).fork()).ldelim();
        }
        if (message.externalDocs !== undefined) {
            exports.ExternalDocumentation.encode(message.externalDocs, writer.uint32(114).fork()).ldelim();
        }
        Object.entries(message.extensions).forEach(([key, value]) => {
            if (value !== undefined) {
                exports.Swagger_ExtensionsEntry.encode({ key: key, value }, writer.uint32(122).fork()).ldelim();
            }
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSwagger();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.swagger = reader.string();
                    break;
                case 2:
                    message.info = exports.Info.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.host = reader.string();
                    break;
                case 4:
                    message.basePath = reader.string();
                    break;
                case 5:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.schemes.push(reader.int32());
                        }
                    }
                    else {
                        message.schemes.push(reader.int32());
                    }
                    break;
                case 6:
                    message.consumes.push(reader.string());
                    break;
                case 7:
                    message.produces.push(reader.string());
                    break;
                case 10:
                    const entry10 = exports.Swagger_ResponsesEntry.decode(reader, reader.uint32());
                    if (entry10.value !== undefined) {
                        message.responses[entry10.key] = entry10.value;
                    }
                    break;
                case 11:
                    message.securityDefinitions = exports.SecurityDefinitions.decode(reader, reader.uint32());
                    break;
                case 12:
                    message.security.push(exports.SecurityRequirement.decode(reader, reader.uint32()));
                    break;
                case 14:
                    message.externalDocs = exports.ExternalDocumentation.decode(reader, reader.uint32());
                    break;
                case 15:
                    const entry15 = exports.Swagger_ExtensionsEntry.decode(reader, reader.uint32());
                    if (entry15.value !== undefined) {
                        message.extensions[entry15.key] = entry15.value;
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSwagger_ResponsesEntry() {
    return { key: "", value: undefined };
}
exports.Swagger_ResponsesEntry = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            exports.Response.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSwagger_ResponsesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = exports.Response.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSwagger_ExtensionsEntry() {
    return { key: "", value: undefined };
}
exports.Swagger_ExtensionsEntry = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            struct_1.Value.encode(struct_1.Value.wrap(message.value), writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSwagger_ExtensionsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = struct_1.Value.unwrap(struct_1.Value.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseOperation() {
    return {
        tags: [],
        summary: "",
        description: "",
        externalDocs: undefined,
        operationId: "",
        consumes: [],
        produces: [],
        responses: {},
        schemes: [],
        deprecated: false,
        security: [],
        extensions: {},
    };
}
exports.Operation = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.tags) {
            writer.uint32(10).string(v);
        }
        if (message.summary !== "") {
            writer.uint32(18).string(message.summary);
        }
        if (message.description !== "") {
            writer.uint32(26).string(message.description);
        }
        if (message.externalDocs !== undefined) {
            exports.ExternalDocumentation.encode(message.externalDocs, writer.uint32(34).fork()).ldelim();
        }
        if (message.operationId !== "") {
            writer.uint32(42).string(message.operationId);
        }
        for (const v of message.consumes) {
            writer.uint32(50).string(v);
        }
        for (const v of message.produces) {
            writer.uint32(58).string(v);
        }
        Object.entries(message.responses).forEach(([key, value]) => {
            exports.Operation_ResponsesEntry.encode({ key: key, value }, writer.uint32(74).fork()).ldelim();
        });
        writer.uint32(82).fork();
        for (const v of message.schemes) {
            writer.int32(v);
        }
        writer.ldelim();
        if (message.deprecated === true) {
            writer.uint32(88).bool(message.deprecated);
        }
        for (const v of message.security) {
            exports.SecurityRequirement.encode(v, writer.uint32(98).fork()).ldelim();
        }
        Object.entries(message.extensions).forEach(([key, value]) => {
            if (value !== undefined) {
                exports.Operation_ExtensionsEntry.encode({ key: key, value }, writer.uint32(106).fork()).ldelim();
            }
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseOperation();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.tags.push(reader.string());
                    break;
                case 2:
                    message.summary = reader.string();
                    break;
                case 3:
                    message.description = reader.string();
                    break;
                case 4:
                    message.externalDocs = exports.ExternalDocumentation.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.operationId = reader.string();
                    break;
                case 6:
                    message.consumes.push(reader.string());
                    break;
                case 7:
                    message.produces.push(reader.string());
                    break;
                case 9:
                    const entry9 = exports.Operation_ResponsesEntry.decode(reader, reader.uint32());
                    if (entry9.value !== undefined) {
                        message.responses[entry9.key] = entry9.value;
                    }
                    break;
                case 10:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.schemes.push(reader.int32());
                        }
                    }
                    else {
                        message.schemes.push(reader.int32());
                    }
                    break;
                case 11:
                    message.deprecated = reader.bool();
                    break;
                case 12:
                    message.security.push(exports.SecurityRequirement.decode(reader, reader.uint32()));
                    break;
                case 13:
                    const entry13 = exports.Operation_ExtensionsEntry.decode(reader, reader.uint32());
                    if (entry13.value !== undefined) {
                        message.extensions[entry13.key] = entry13.value;
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseOperation_ResponsesEntry() {
    return { key: "", value: undefined };
}
exports.Operation_ResponsesEntry = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            exports.Response.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseOperation_ResponsesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = exports.Response.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseOperation_ExtensionsEntry() {
    return { key: "", value: undefined };
}
exports.Operation_ExtensionsEntry = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            struct_1.Value.encode(struct_1.Value.wrap(message.value), writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseOperation_ExtensionsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = struct_1.Value.unwrap(struct_1.Value.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseHeader() {
    return { description: "", type: "", format: "", default: "", pattern: "" };
}
exports.Header = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.description !== "") {
            writer.uint32(10).string(message.description);
        }
        if (message.type !== "") {
            writer.uint32(18).string(message.type);
        }
        if (message.format !== "") {
            writer.uint32(26).string(message.format);
        }
        if (message.default !== "") {
            writer.uint32(50).string(message.default);
        }
        if (message.pattern !== "") {
            writer.uint32(106).string(message.pattern);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHeader();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.description = reader.string();
                    break;
                case 2:
                    message.type = reader.string();
                    break;
                case 3:
                    message.format = reader.string();
                    break;
                case 6:
                    message.default = reader.string();
                    break;
                case 13:
                    message.pattern = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseResponse() {
    return {
        description: "",
        schema: undefined,
        headers: {},
        examples: {},
        extensions: {},
    };
}
exports.Response = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.description !== "") {
            writer.uint32(10).string(message.description);
        }
        if (message.schema !== undefined) {
            exports.Schema.encode(message.schema, writer.uint32(18).fork()).ldelim();
        }
        Object.entries(message.headers).forEach(([key, value]) => {
            exports.Response_HeadersEntry.encode({ key: key, value }, writer.uint32(26).fork()).ldelim();
        });
        Object.entries(message.examples).forEach(([key, value]) => {
            exports.Response_ExamplesEntry.encode({ key: key, value }, writer.uint32(34).fork()).ldelim();
        });
        Object.entries(message.extensions).forEach(([key, value]) => {
            if (value !== undefined) {
                exports.Response_ExtensionsEntry.encode({ key: key, value }, writer.uint32(42).fork()).ldelim();
            }
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.description = reader.string();
                    break;
                case 2:
                    message.schema = exports.Schema.decode(reader, reader.uint32());
                    break;
                case 3:
                    const entry3 = exports.Response_HeadersEntry.decode(reader, reader.uint32());
                    if (entry3.value !== undefined) {
                        message.headers[entry3.key] = entry3.value;
                    }
                    break;
                case 4:
                    const entry4 = exports.Response_ExamplesEntry.decode(reader, reader.uint32());
                    if (entry4.value !== undefined) {
                        message.examples[entry4.key] = entry4.value;
                    }
                    break;
                case 5:
                    const entry5 = exports.Response_ExtensionsEntry.decode(reader, reader.uint32());
                    if (entry5.value !== undefined) {
                        message.extensions[entry5.key] = entry5.value;
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseResponse_HeadersEntry() {
    return { key: "", value: undefined };
}
exports.Response_HeadersEntry = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            exports.Header.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseResponse_HeadersEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = exports.Header.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseResponse_ExamplesEntry() {
    return { key: "", value: "" };
}
exports.Response_ExamplesEntry = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseResponse_ExamplesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseResponse_ExtensionsEntry() {
    return { key: "", value: undefined };
}
exports.Response_ExtensionsEntry = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            struct_1.Value.encode(struct_1.Value.wrap(message.value), writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseResponse_ExtensionsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = struct_1.Value.unwrap(struct_1.Value.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseInfo() {
    return {
        title: "",
        description: "",
        termsOfService: "",
        contact: undefined,
        license: undefined,
        version: "",
        extensions: {},
    };
}
exports.Info = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.title !== "") {
            writer.uint32(10).string(message.title);
        }
        if (message.description !== "") {
            writer.uint32(18).string(message.description);
        }
        if (message.termsOfService !== "") {
            writer.uint32(26).string(message.termsOfService);
        }
        if (message.contact !== undefined) {
            exports.Contact.encode(message.contact, writer.uint32(34).fork()).ldelim();
        }
        if (message.license !== undefined) {
            exports.License.encode(message.license, writer.uint32(42).fork()).ldelim();
        }
        if (message.version !== "") {
            writer.uint32(50).string(message.version);
        }
        Object.entries(message.extensions).forEach(([key, value]) => {
            if (value !== undefined) {
                exports.Info_ExtensionsEntry.encode({ key: key, value }, writer.uint32(58).fork()).ldelim();
            }
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.title = reader.string();
                    break;
                case 2:
                    message.description = reader.string();
                    break;
                case 3:
                    message.termsOfService = reader.string();
                    break;
                case 4:
                    message.contact = exports.Contact.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.license = exports.License.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.version = reader.string();
                    break;
                case 7:
                    const entry7 = exports.Info_ExtensionsEntry.decode(reader, reader.uint32());
                    if (entry7.value !== undefined) {
                        message.extensions[entry7.key] = entry7.value;
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseInfo_ExtensionsEntry() {
    return { key: "", value: undefined };
}
exports.Info_ExtensionsEntry = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            struct_1.Value.encode(struct_1.Value.wrap(message.value), writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInfo_ExtensionsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = struct_1.Value.unwrap(struct_1.Value.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseContact() {
    return { name: "", url: "", email: "" };
}
exports.Contact = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.url !== "") {
            writer.uint32(18).string(message.url);
        }
        if (message.email !== "") {
            writer.uint32(26).string(message.email);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseContact();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.url = reader.string();
                    break;
                case 3:
                    message.email = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseLicense() {
    return { name: "", url: "" };
}
exports.License = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.url !== "") {
            writer.uint32(18).string(message.url);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLicense();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.url = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseExternalDocumentation() {
    return { description: "", url: "" };
}
exports.ExternalDocumentation = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.description !== "") {
            writer.uint32(10).string(message.description);
        }
        if (message.url !== "") {
            writer.uint32(18).string(message.url);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseExternalDocumentation();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.description = reader.string();
                    break;
                case 2:
                    message.url = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSchema() {
    return {
        jsonSchema: undefined,
        discriminator: "",
        readOnly: false,
        externalDocs: undefined,
        example: "",
    };
}
exports.Schema = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.jsonSchema !== undefined) {
            exports.JSONSchema.encode(message.jsonSchema, writer.uint32(10).fork()).ldelim();
        }
        if (message.discriminator !== "") {
            writer.uint32(18).string(message.discriminator);
        }
        if (message.readOnly === true) {
            writer.uint32(24).bool(message.readOnly);
        }
        if (message.externalDocs !== undefined) {
            exports.ExternalDocumentation.encode(message.externalDocs, writer.uint32(42).fork()).ldelim();
        }
        if (message.example !== "") {
            writer.uint32(50).string(message.example);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSchema();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.jsonSchema = exports.JSONSchema.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.discriminator = reader.string();
                    break;
                case 3:
                    message.readOnly = reader.bool();
                    break;
                case 5:
                    message.externalDocs = exports.ExternalDocumentation.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.example = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseJSONSchema() {
    return {
        ref: "",
        title: "",
        description: "",
        default: "",
        readOnly: false,
        example: "",
        multipleOf: 0,
        maximum: 0,
        exclusiveMaximum: false,
        minimum: 0,
        exclusiveMinimum: false,
        maxLength: 0,
        minLength: 0,
        pattern: "",
        maxItems: 0,
        minItems: 0,
        uniqueItems: false,
        maxProperties: 0,
        minProperties: 0,
        required: [],
        array: [],
        type: [],
        format: "",
        enum: [],
    };
}
exports.JSONSchema = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.ref !== "") {
            writer.uint32(26).string(message.ref);
        }
        if (message.title !== "") {
            writer.uint32(42).string(message.title);
        }
        if (message.description !== "") {
            writer.uint32(50).string(message.description);
        }
        if (message.default !== "") {
            writer.uint32(58).string(message.default);
        }
        if (message.readOnly === true) {
            writer.uint32(64).bool(message.readOnly);
        }
        if (message.example !== "") {
            writer.uint32(74).string(message.example);
        }
        if (message.multipleOf !== 0) {
            writer.uint32(81).double(message.multipleOf);
        }
        if (message.maximum !== 0) {
            writer.uint32(89).double(message.maximum);
        }
        if (message.exclusiveMaximum === true) {
            writer.uint32(96).bool(message.exclusiveMaximum);
        }
        if (message.minimum !== 0) {
            writer.uint32(105).double(message.minimum);
        }
        if (message.exclusiveMinimum === true) {
            writer.uint32(112).bool(message.exclusiveMinimum);
        }
        if (message.maxLength !== 0) {
            writer.uint32(120).uint64(message.maxLength);
        }
        if (message.minLength !== 0) {
            writer.uint32(128).uint64(message.minLength);
        }
        if (message.pattern !== "") {
            writer.uint32(138).string(message.pattern);
        }
        if (message.maxItems !== 0) {
            writer.uint32(160).uint64(message.maxItems);
        }
        if (message.minItems !== 0) {
            writer.uint32(168).uint64(message.minItems);
        }
        if (message.uniqueItems === true) {
            writer.uint32(176).bool(message.uniqueItems);
        }
        if (message.maxProperties !== 0) {
            writer.uint32(192).uint64(message.maxProperties);
        }
        if (message.minProperties !== 0) {
            writer.uint32(200).uint64(message.minProperties);
        }
        for (const v of message.required) {
            writer.uint32(210).string(v);
        }
        for (const v of message.array) {
            writer.uint32(274).string(v);
        }
        writer.uint32(282).fork();
        for (const v of message.type) {
            writer.int32(v);
        }
        writer.ldelim();
        if (message.format !== "") {
            writer.uint32(290).string(message.format);
        }
        for (const v of message.enum) {
            writer.uint32(370).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseJSONSchema();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 3:
                    message.ref = reader.string();
                    break;
                case 5:
                    message.title = reader.string();
                    break;
                case 6:
                    message.description = reader.string();
                    break;
                case 7:
                    message.default = reader.string();
                    break;
                case 8:
                    message.readOnly = reader.bool();
                    break;
                case 9:
                    message.example = reader.string();
                    break;
                case 10:
                    message.multipleOf = reader.double();
                    break;
                case 11:
                    message.maximum = reader.double();
                    break;
                case 12:
                    message.exclusiveMaximum = reader.bool();
                    break;
                case 13:
                    message.minimum = reader.double();
                    break;
                case 14:
                    message.exclusiveMinimum = reader.bool();
                    break;
                case 15:
                    message.maxLength = longToNumber(reader.uint64());
                    break;
                case 16:
                    message.minLength = longToNumber(reader.uint64());
                    break;
                case 17:
                    message.pattern = reader.string();
                    break;
                case 20:
                    message.maxItems = longToNumber(reader.uint64());
                    break;
                case 21:
                    message.minItems = longToNumber(reader.uint64());
                    break;
                case 22:
                    message.uniqueItems = reader.bool();
                    break;
                case 24:
                    message.maxProperties = longToNumber(reader.uint64());
                    break;
                case 25:
                    message.minProperties = longToNumber(reader.uint64());
                    break;
                case 26:
                    message.required.push(reader.string());
                    break;
                case 34:
                    message.array.push(reader.string());
                    break;
                case 35:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.type.push(reader.int32());
                        }
                    }
                    else {
                        message.type.push(reader.int32());
                    }
                    break;
                case 36:
                    message.format = reader.string();
                    break;
                case 46:
                    message.enum.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseTag() {
    return { description: "", externalDocs: undefined };
}
exports.Tag = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.description !== "") {
            writer.uint32(18).string(message.description);
        }
        if (message.externalDocs !== undefined) {
            exports.ExternalDocumentation.encode(message.externalDocs, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTag();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2:
                    message.description = reader.string();
                    break;
                case 3:
                    message.externalDocs = exports.ExternalDocumentation.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSecurityDefinitions() {
    return { security: {} };
}
exports.SecurityDefinitions = {
    encode(message, writer = _m0.Writer.create()) {
        Object.entries(message.security).forEach(([key, value]) => {
            exports.SecurityDefinitions_SecurityEntry.encode({ key: key, value }, writer.uint32(10).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSecurityDefinitions();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    const entry1 = exports.SecurityDefinitions_SecurityEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.security[entry1.key] = entry1.value;
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSecurityDefinitions_SecurityEntry() {
    return { key: "", value: undefined };
}
exports.SecurityDefinitions_SecurityEntry = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            exports.SecurityScheme.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSecurityDefinitions_SecurityEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = exports.SecurityScheme.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSecurityScheme() {
    return {
        type: 0,
        description: "",
        name: "",
        in: 0,
        flow: 0,
        authorizationUrl: "",
        tokenUrl: "",
        scopes: undefined,
        extensions: {},
    };
}
exports.SecurityScheme = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.type !== 0) {
            writer.uint32(8).int32(message.type);
        }
        if (message.description !== "") {
            writer.uint32(18).string(message.description);
        }
        if (message.name !== "") {
            writer.uint32(26).string(message.name);
        }
        if (message.in !== 0) {
            writer.uint32(32).int32(message.in);
        }
        if (message.flow !== 0) {
            writer.uint32(40).int32(message.flow);
        }
        if (message.authorizationUrl !== "") {
            writer.uint32(50).string(message.authorizationUrl);
        }
        if (message.tokenUrl !== "") {
            writer.uint32(58).string(message.tokenUrl);
        }
        if (message.scopes !== undefined) {
            exports.Scopes.encode(message.scopes, writer.uint32(66).fork()).ldelim();
        }
        Object.entries(message.extensions).forEach(([key, value]) => {
            if (value !== undefined) {
                exports.SecurityScheme_ExtensionsEntry.encode({ key: key, value }, writer.uint32(74).fork()).ldelim();
            }
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSecurityScheme();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.description = reader.string();
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                case 4:
                    message.in = reader.int32();
                    break;
                case 5:
                    message.flow = reader.int32();
                    break;
                case 6:
                    message.authorizationUrl = reader.string();
                    break;
                case 7:
                    message.tokenUrl = reader.string();
                    break;
                case 8:
                    message.scopes = exports.Scopes.decode(reader, reader.uint32());
                    break;
                case 9:
                    const entry9 = exports.SecurityScheme_ExtensionsEntry.decode(reader, reader.uint32());
                    if (entry9.value !== undefined) {
                        message.extensions[entry9.key] = entry9.value;
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSecurityScheme_ExtensionsEntry() {
    return { key: "", value: undefined };
}
exports.SecurityScheme_ExtensionsEntry = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            struct_1.Value.encode(struct_1.Value.wrap(message.value), writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSecurityScheme_ExtensionsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = struct_1.Value.unwrap(struct_1.Value.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSecurityRequirement() {
    return { securityRequirement: {} };
}
exports.SecurityRequirement = {
    encode(message, writer = _m0.Writer.create()) {
        Object.entries(message.securityRequirement).forEach(([key, value]) => {
            exports.SecurityRequirement_SecurityRequirementEntry.encode({ key: key, value }, writer.uint32(10).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSecurityRequirement();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    const entry1 = exports.SecurityRequirement_SecurityRequirementEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.securityRequirement[entry1.key] = entry1.value;
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSecurityRequirement_SecurityRequirementValue() {
    return { scope: [] };
}
exports.SecurityRequirement_SecurityRequirementValue = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.scope) {
            writer.uint32(10).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSecurityRequirement_SecurityRequirementValue();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.scope.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSecurityRequirement_SecurityRequirementEntry() {
    return { key: "", value: undefined };
}
exports.SecurityRequirement_SecurityRequirementEntry = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            exports.SecurityRequirement_SecurityRequirementValue.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSecurityRequirement_SecurityRequirementEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = exports.SecurityRequirement_SecurityRequirementValue.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseScopes() {
    return { scope: {} };
}
exports.Scopes = {
    encode(message, writer = _m0.Writer.create()) {
        Object.entries(message.scope).forEach(([key, value]) => {
            exports.Scopes_ScopeEntry.encode({ key: key, value }, writer.uint32(10).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseScopes();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    const entry1 = exports.Scopes_ScopeEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.scope[entry1.key] = entry1.value;
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseScopes_ScopeEntry() {
    return { key: "", value: "" };
}
exports.Scopes_ScopeEntry = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseScopes_ScopeEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
var globalThis = (() => {
    if (typeof globalThis !== "undefined")
        return globalThis;
    if (typeof self !== "undefined")
        return self;
    if (typeof window !== "undefined")
        return window;
    if (typeof global !== "undefined")
        return global;
    throw "Unable to locate global object";
})();
function longToNumber(long) {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (_m0.util.Long !== long_1.default) {
    _m0.util.Long = long_1.default;
    _m0.configure();
}
//# sourceMappingURL=openapiv2.js.map