"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Reference = exports.Decl_FunctionDecl_Overload = exports.Decl_FunctionDecl = exports.Decl_IdentDecl = exports.Decl = exports.Type_AbstractType = exports.Type_FunctionType = exports.Type_MapType = exports.Type_ListType = exports.Type = exports.CheckedExpr_TypeMapEntry = exports.CheckedExpr_ReferenceMapEntry = exports.CheckedExpr = exports.Type_WellKnownType = exports.Type_PrimitiveType = exports.protobufPackage = void 0;
/* eslint-disable */
const long_1 = __importDefault(require("long"));
const syntax_1 = require("../../../../google/api/expr/v1alpha1/syntax");
const _m0 = __importStar(require("protobufjs/minimal"));
const empty_1 = require("../../../../google/protobuf/empty");
exports.protobufPackage = "google.api.expr.v1alpha1";
/** CEL primitive types. */
var Type_PrimitiveType;
(function (Type_PrimitiveType) {
    /** PRIMITIVE_TYPE_UNSPECIFIED - Unspecified type. */
    Type_PrimitiveType[Type_PrimitiveType["PRIMITIVE_TYPE_UNSPECIFIED"] = 0] = "PRIMITIVE_TYPE_UNSPECIFIED";
    /** BOOL - Boolean type. */
    Type_PrimitiveType[Type_PrimitiveType["BOOL"] = 1] = "BOOL";
    /**
     * INT64 - Int64 type.
     *
     * Proto-based integer values are widened to int64.
     */
    Type_PrimitiveType[Type_PrimitiveType["INT64"] = 2] = "INT64";
    /**
     * UINT64 - Uint64 type.
     *
     * Proto-based unsigned integer values are widened to uint64.
     */
    Type_PrimitiveType[Type_PrimitiveType["UINT64"] = 3] = "UINT64";
    /**
     * DOUBLE - Double type.
     *
     * Proto-based float values are widened to double values.
     */
    Type_PrimitiveType[Type_PrimitiveType["DOUBLE"] = 4] = "DOUBLE";
    /** STRING - String type. */
    Type_PrimitiveType[Type_PrimitiveType["STRING"] = 5] = "STRING";
    /** BYTES - Bytes type. */
    Type_PrimitiveType[Type_PrimitiveType["BYTES"] = 6] = "BYTES";
})(Type_PrimitiveType = exports.Type_PrimitiveType || (exports.Type_PrimitiveType = {}));
/** Well-known protobuf types treated with first-class support in CEL. */
var Type_WellKnownType;
(function (Type_WellKnownType) {
    /** WELL_KNOWN_TYPE_UNSPECIFIED - Unspecified type. */
    Type_WellKnownType[Type_WellKnownType["WELL_KNOWN_TYPE_UNSPECIFIED"] = 0] = "WELL_KNOWN_TYPE_UNSPECIFIED";
    /**
     * ANY - Well-known protobuf.Any type.
     *
     * Any types are a polymorphic message type. During type-checking they are
     * treated like `DYN` types, but at runtime they are resolved to a specific
     * message type specified at evaluation time.
     */
    Type_WellKnownType[Type_WellKnownType["ANY"] = 1] = "ANY";
    /** TIMESTAMP - Well-known protobuf.Timestamp type, internally referenced as `timestamp`. */
    Type_WellKnownType[Type_WellKnownType["TIMESTAMP"] = 2] = "TIMESTAMP";
    /** DURATION - Well-known protobuf.Duration type, internally referenced as `duration`. */
    Type_WellKnownType[Type_WellKnownType["DURATION"] = 3] = "DURATION";
})(Type_WellKnownType = exports.Type_WellKnownType || (exports.Type_WellKnownType = {}));
function createBaseCheckedExpr() {
    return {
        referenceMap: {},
        typeMap: {},
        sourceInfo: undefined,
        exprVersion: "",
        expr: undefined,
    };
}
exports.CheckedExpr = {
    encode(message, writer = _m0.Writer.create()) {
        Object.entries(message.referenceMap).forEach(([key, value]) => {
            exports.CheckedExpr_ReferenceMapEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();
        });
        Object.entries(message.typeMap).forEach(([key, value]) => {
            exports.CheckedExpr_TypeMapEntry.encode({ key: key, value }, writer.uint32(26).fork()).ldelim();
        });
        if (message.sourceInfo !== undefined) {
            syntax_1.SourceInfo.encode(message.sourceInfo, writer.uint32(42).fork()).ldelim();
        }
        if (message.exprVersion !== "") {
            writer.uint32(50).string(message.exprVersion);
        }
        if (message.expr !== undefined) {
            syntax_1.Expr.encode(message.expr, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCheckedExpr();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2:
                    const entry2 = exports.CheckedExpr_ReferenceMapEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.referenceMap[entry2.key] = entry2.value;
                    }
                    break;
                case 3:
                    const entry3 = exports.CheckedExpr_TypeMapEntry.decode(reader, reader.uint32());
                    if (entry3.value !== undefined) {
                        message.typeMap[entry3.key] = entry3.value;
                    }
                    break;
                case 5:
                    message.sourceInfo = syntax_1.SourceInfo.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.exprVersion = reader.string();
                    break;
                case 4:
                    message.expr = syntax_1.Expr.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseCheckedExpr_ReferenceMapEntry() {
    return { key: 0, value: undefined };
}
exports.CheckedExpr_ReferenceMapEntry = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== 0) {
            writer.uint32(8).int64(message.key);
        }
        if (message.value !== undefined) {
            exports.Reference.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCheckedExpr_ReferenceMapEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = longToNumber(reader.int64());
                    break;
                case 2:
                    message.value = exports.Reference.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseCheckedExpr_TypeMapEntry() {
    return { key: 0, value: undefined };
}
exports.CheckedExpr_TypeMapEntry = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== 0) {
            writer.uint32(8).int64(message.key);
        }
        if (message.value !== undefined) {
            exports.Type.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCheckedExpr_TypeMapEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = longToNumber(reader.int64());
                    break;
                case 2:
                    message.value = exports.Type.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseType() {
    return { typeKind: undefined };
}
exports.Type = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.typeKind?.$case === "dyn") {
            empty_1.Empty.encode(message.typeKind.dyn, writer.uint32(10).fork()).ldelim();
        }
        if (message.typeKind?.$case === "null") {
            writer.uint32(16).int32(message.typeKind.null);
        }
        if (message.typeKind?.$case === "primitive") {
            writer.uint32(24).int32(message.typeKind.primitive);
        }
        if (message.typeKind?.$case === "wrapper") {
            writer.uint32(32).int32(message.typeKind.wrapper);
        }
        if (message.typeKind?.$case === "wellKnown") {
            writer.uint32(40).int32(message.typeKind.wellKnown);
        }
        if (message.typeKind?.$case === "listType") {
            exports.Type_ListType.encode(message.typeKind.listType, writer.uint32(50).fork()).ldelim();
        }
        if (message.typeKind?.$case === "mapType") {
            exports.Type_MapType.encode(message.typeKind.mapType, writer.uint32(58).fork()).ldelim();
        }
        if (message.typeKind?.$case === "function") {
            exports.Type_FunctionType.encode(message.typeKind.function, writer.uint32(66).fork()).ldelim();
        }
        if (message.typeKind?.$case === "messageType") {
            writer.uint32(74).string(message.typeKind.messageType);
        }
        if (message.typeKind?.$case === "typeParam") {
            writer.uint32(82).string(message.typeKind.typeParam);
        }
        if (message.typeKind?.$case === "type") {
            exports.Type.encode(message.typeKind.type, writer.uint32(90).fork()).ldelim();
        }
        if (message.typeKind?.$case === "error") {
            empty_1.Empty.encode(message.typeKind.error, writer.uint32(98).fork()).ldelim();
        }
        if (message.typeKind?.$case === "abstractType") {
            exports.Type_AbstractType.encode(message.typeKind.abstractType, writer.uint32(114).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseType();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.typeKind = {
                        $case: "dyn",
                        dyn: empty_1.Empty.decode(reader, reader.uint32()),
                    };
                    break;
                case 2:
                    message.typeKind = { $case: "null", null: reader.int32() };
                    break;
                case 3:
                    message.typeKind = {
                        $case: "primitive",
                        primitive: reader.int32(),
                    };
                    break;
                case 4:
                    message.typeKind = {
                        $case: "wrapper",
                        wrapper: reader.int32(),
                    };
                    break;
                case 5:
                    message.typeKind = {
                        $case: "wellKnown",
                        wellKnown: reader.int32(),
                    };
                    break;
                case 6:
                    message.typeKind = {
                        $case: "listType",
                        listType: exports.Type_ListType.decode(reader, reader.uint32()),
                    };
                    break;
                case 7:
                    message.typeKind = {
                        $case: "mapType",
                        mapType: exports.Type_MapType.decode(reader, reader.uint32()),
                    };
                    break;
                case 8:
                    message.typeKind = {
                        $case: "function",
                        function: exports.Type_FunctionType.decode(reader, reader.uint32()),
                    };
                    break;
                case 9:
                    message.typeKind = {
                        $case: "messageType",
                        messageType: reader.string(),
                    };
                    break;
                case 10:
                    message.typeKind = { $case: "typeParam", typeParam: reader.string() };
                    break;
                case 11:
                    message.typeKind = {
                        $case: "type",
                        type: exports.Type.decode(reader, reader.uint32()),
                    };
                    break;
                case 12:
                    message.typeKind = {
                        $case: "error",
                        error: empty_1.Empty.decode(reader, reader.uint32()),
                    };
                    break;
                case 14:
                    message.typeKind = {
                        $case: "abstractType",
                        abstractType: exports.Type_AbstractType.decode(reader, reader.uint32()),
                    };
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseType_ListType() {
    return { elemType: undefined };
}
exports.Type_ListType = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.elemType !== undefined) {
            exports.Type.encode(message.elemType, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseType_ListType();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.elemType = exports.Type.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseType_MapType() {
    return { keyType: undefined, valueType: undefined };
}
exports.Type_MapType = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.keyType !== undefined) {
            exports.Type.encode(message.keyType, writer.uint32(10).fork()).ldelim();
        }
        if (message.valueType !== undefined) {
            exports.Type.encode(message.valueType, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseType_MapType();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.keyType = exports.Type.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.valueType = exports.Type.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseType_FunctionType() {
    return { resultType: undefined, argTypes: [] };
}
exports.Type_FunctionType = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.resultType !== undefined) {
            exports.Type.encode(message.resultType, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.argTypes) {
            exports.Type.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseType_FunctionType();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.resultType = exports.Type.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.argTypes.push(exports.Type.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseType_AbstractType() {
    return { name: "", parameterTypes: [] };
}
exports.Type_AbstractType = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        for (const v of message.parameterTypes) {
            exports.Type.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseType_AbstractType();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.parameterTypes.push(exports.Type.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseDecl() {
    return { name: "", declKind: undefined };
}
exports.Decl = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.declKind?.$case === "ident") {
            exports.Decl_IdentDecl.encode(message.declKind.ident, writer.uint32(18).fork()).ldelim();
        }
        if (message.declKind?.$case === "function") {
            exports.Decl_FunctionDecl.encode(message.declKind.function, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDecl();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.declKind = {
                        $case: "ident",
                        ident: exports.Decl_IdentDecl.decode(reader, reader.uint32()),
                    };
                    break;
                case 3:
                    message.declKind = {
                        $case: "function",
                        function: exports.Decl_FunctionDecl.decode(reader, reader.uint32()),
                    };
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseDecl_IdentDecl() {
    return { type: undefined, value: undefined, doc: "" };
}
exports.Decl_IdentDecl = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.type !== undefined) {
            exports.Type.encode(message.type, writer.uint32(10).fork()).ldelim();
        }
        if (message.value !== undefined) {
            syntax_1.Constant.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        if (message.doc !== "") {
            writer.uint32(26).string(message.doc);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDecl_IdentDecl();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.type = exports.Type.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.value = syntax_1.Constant.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.doc = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseDecl_FunctionDecl() {
    return { overloads: [] };
}
exports.Decl_FunctionDecl = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.overloads) {
            exports.Decl_FunctionDecl_Overload.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDecl_FunctionDecl();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.overloads.push(exports.Decl_FunctionDecl_Overload.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseDecl_FunctionDecl_Overload() {
    return {
        overloadId: "",
        params: [],
        typeParams: [],
        resultType: undefined,
        isInstanceFunction: false,
        doc: "",
    };
}
exports.Decl_FunctionDecl_Overload = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.overloadId !== "") {
            writer.uint32(10).string(message.overloadId);
        }
        for (const v of message.params) {
            exports.Type.encode(v, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.typeParams) {
            writer.uint32(26).string(v);
        }
        if (message.resultType !== undefined) {
            exports.Type.encode(message.resultType, writer.uint32(34).fork()).ldelim();
        }
        if (message.isInstanceFunction === true) {
            writer.uint32(40).bool(message.isInstanceFunction);
        }
        if (message.doc !== "") {
            writer.uint32(50).string(message.doc);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDecl_FunctionDecl_Overload();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.overloadId = reader.string();
                    break;
                case 2:
                    message.params.push(exports.Type.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.typeParams.push(reader.string());
                    break;
                case 4:
                    message.resultType = exports.Type.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.isInstanceFunction = reader.bool();
                    break;
                case 6:
                    message.doc = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseReference() {
    return { name: "", overloadId: [], value: undefined };
}
exports.Reference = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        for (const v of message.overloadId) {
            writer.uint32(26).string(v);
        }
        if (message.value !== undefined) {
            syntax_1.Constant.encode(message.value, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseReference();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 3:
                    message.overloadId.push(reader.string());
                    break;
                case 4:
                    message.value = syntax_1.Constant.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
var globalThis = (() => {
    if (typeof globalThis !== "undefined")
        return globalThis;
    if (typeof self !== "undefined")
        return self;
    if (typeof window !== "undefined")
        return window;
    if (typeof global !== "undefined")
        return global;
    throw "Unable to locate global object";
})();
function longToNumber(long) {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (_m0.util.Long !== long_1.default) {
    _m0.util.Long = long_1.default;
    _m0.configure();
}
//# sourceMappingURL=checked.js.map