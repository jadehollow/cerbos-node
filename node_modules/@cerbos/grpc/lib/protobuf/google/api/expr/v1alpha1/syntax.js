"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SourcePosition = exports.SourceInfo_MacroCallsEntry = exports.SourceInfo_PositionsEntry = exports.SourceInfo = exports.Constant = exports.Expr_Comprehension = exports.Expr_CreateStruct_Entry = exports.Expr_CreateStruct = exports.Expr_CreateList = exports.Expr_Call = exports.Expr_Select = exports.Expr_Ident = exports.Expr = exports.ParsedExpr = exports.protobufPackage = void 0;
/* eslint-disable */
const timestamp_1 = require("../../../../google/protobuf/timestamp");
const long_1 = __importDefault(require("long"));
const _m0 = __importStar(require("protobufjs/minimal"));
const duration_1 = require("../../../../google/protobuf/duration");
exports.protobufPackage = "google.api.expr.v1alpha1";
function createBaseParsedExpr() {
    return { expr: undefined, sourceInfo: undefined };
}
exports.ParsedExpr = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.expr !== undefined) {
            exports.Expr.encode(message.expr, writer.uint32(18).fork()).ldelim();
        }
        if (message.sourceInfo !== undefined) {
            exports.SourceInfo.encode(message.sourceInfo, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseParsedExpr();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2:
                    message.expr = exports.Expr.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.sourceInfo = exports.SourceInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseExpr() {
    return { id: 0, exprKind: undefined };
}
exports.Expr = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== 0) {
            writer.uint32(16).int64(message.id);
        }
        if (message.exprKind?.$case === "constExpr") {
            exports.Constant.encode(message.exprKind.constExpr, writer.uint32(26).fork()).ldelim();
        }
        if (message.exprKind?.$case === "identExpr") {
            exports.Expr_Ident.encode(message.exprKind.identExpr, writer.uint32(34).fork()).ldelim();
        }
        if (message.exprKind?.$case === "selectExpr") {
            exports.Expr_Select.encode(message.exprKind.selectExpr, writer.uint32(42).fork()).ldelim();
        }
        if (message.exprKind?.$case === "callExpr") {
            exports.Expr_Call.encode(message.exprKind.callExpr, writer.uint32(50).fork()).ldelim();
        }
        if (message.exprKind?.$case === "listExpr") {
            exports.Expr_CreateList.encode(message.exprKind.listExpr, writer.uint32(58).fork()).ldelim();
        }
        if (message.exprKind?.$case === "structExpr") {
            exports.Expr_CreateStruct.encode(message.exprKind.structExpr, writer.uint32(66).fork()).ldelim();
        }
        if (message.exprKind?.$case === "comprehensionExpr") {
            exports.Expr_Comprehension.encode(message.exprKind.comprehensionExpr, writer.uint32(74).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseExpr();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2:
                    message.id = longToNumber(reader.int64());
                    break;
                case 3:
                    message.exprKind = {
                        $case: "constExpr",
                        constExpr: exports.Constant.decode(reader, reader.uint32()),
                    };
                    break;
                case 4:
                    message.exprKind = {
                        $case: "identExpr",
                        identExpr: exports.Expr_Ident.decode(reader, reader.uint32()),
                    };
                    break;
                case 5:
                    message.exprKind = {
                        $case: "selectExpr",
                        selectExpr: exports.Expr_Select.decode(reader, reader.uint32()),
                    };
                    break;
                case 6:
                    message.exprKind = {
                        $case: "callExpr",
                        callExpr: exports.Expr_Call.decode(reader, reader.uint32()),
                    };
                    break;
                case 7:
                    message.exprKind = {
                        $case: "listExpr",
                        listExpr: exports.Expr_CreateList.decode(reader, reader.uint32()),
                    };
                    break;
                case 8:
                    message.exprKind = {
                        $case: "structExpr",
                        structExpr: exports.Expr_CreateStruct.decode(reader, reader.uint32()),
                    };
                    break;
                case 9:
                    message.exprKind = {
                        $case: "comprehensionExpr",
                        comprehensionExpr: exports.Expr_Comprehension.decode(reader, reader.uint32()),
                    };
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseExpr_Ident() {
    return { name: "" };
}
exports.Expr_Ident = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseExpr_Ident();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseExpr_Select() {
    return { operand: undefined, field: "", testOnly: false };
}
exports.Expr_Select = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.operand !== undefined) {
            exports.Expr.encode(message.operand, writer.uint32(10).fork()).ldelim();
        }
        if (message.field !== "") {
            writer.uint32(18).string(message.field);
        }
        if (message.testOnly === true) {
            writer.uint32(24).bool(message.testOnly);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseExpr_Select();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.operand = exports.Expr.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.field = reader.string();
                    break;
                case 3:
                    message.testOnly = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseExpr_Call() {
    return { target: undefined, function: "", args: [] };
}
exports.Expr_Call = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.target !== undefined) {
            exports.Expr.encode(message.target, writer.uint32(10).fork()).ldelim();
        }
        if (message.function !== "") {
            writer.uint32(18).string(message.function);
        }
        for (const v of message.args) {
            exports.Expr.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseExpr_Call();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.target = exports.Expr.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.function = reader.string();
                    break;
                case 3:
                    message.args.push(exports.Expr.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseExpr_CreateList() {
    return { elements: [] };
}
exports.Expr_CreateList = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.elements) {
            exports.Expr.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseExpr_CreateList();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.elements.push(exports.Expr.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseExpr_CreateStruct() {
    return { messageName: "", entries: [] };
}
exports.Expr_CreateStruct = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.messageName !== "") {
            writer.uint32(10).string(message.messageName);
        }
        for (const v of message.entries) {
            exports.Expr_CreateStruct_Entry.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseExpr_CreateStruct();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.messageName = reader.string();
                    break;
                case 2:
                    message.entries.push(exports.Expr_CreateStruct_Entry.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseExpr_CreateStruct_Entry() {
    return { id: 0, keyKind: undefined, value: undefined };
}
exports.Expr_CreateStruct_Entry = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== 0) {
            writer.uint32(8).int64(message.id);
        }
        if (message.keyKind?.$case === "fieldKey") {
            writer.uint32(18).string(message.keyKind.fieldKey);
        }
        if (message.keyKind?.$case === "mapKey") {
            exports.Expr.encode(message.keyKind.mapKey, writer.uint32(26).fork()).ldelim();
        }
        if (message.value !== undefined) {
            exports.Expr.encode(message.value, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseExpr_CreateStruct_Entry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = longToNumber(reader.int64());
                    break;
                case 2:
                    message.keyKind = { $case: "fieldKey", fieldKey: reader.string() };
                    break;
                case 3:
                    message.keyKind = {
                        $case: "mapKey",
                        mapKey: exports.Expr.decode(reader, reader.uint32()),
                    };
                    break;
                case 4:
                    message.value = exports.Expr.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseExpr_Comprehension() {
    return {
        iterVar: "",
        iterRange: undefined,
        accuVar: "",
        accuInit: undefined,
        loopCondition: undefined,
        loopStep: undefined,
        result: undefined,
    };
}
exports.Expr_Comprehension = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.iterVar !== "") {
            writer.uint32(10).string(message.iterVar);
        }
        if (message.iterRange !== undefined) {
            exports.Expr.encode(message.iterRange, writer.uint32(18).fork()).ldelim();
        }
        if (message.accuVar !== "") {
            writer.uint32(26).string(message.accuVar);
        }
        if (message.accuInit !== undefined) {
            exports.Expr.encode(message.accuInit, writer.uint32(34).fork()).ldelim();
        }
        if (message.loopCondition !== undefined) {
            exports.Expr.encode(message.loopCondition, writer.uint32(42).fork()).ldelim();
        }
        if (message.loopStep !== undefined) {
            exports.Expr.encode(message.loopStep, writer.uint32(50).fork()).ldelim();
        }
        if (message.result !== undefined) {
            exports.Expr.encode(message.result, writer.uint32(58).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseExpr_Comprehension();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.iterVar = reader.string();
                    break;
                case 2:
                    message.iterRange = exports.Expr.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.accuVar = reader.string();
                    break;
                case 4:
                    message.accuInit = exports.Expr.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.loopCondition = exports.Expr.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.loopStep = exports.Expr.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.result = exports.Expr.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseConstant() {
    return { constantKind: undefined };
}
exports.Constant = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.constantKind?.$case === "nullValue") {
            writer.uint32(8).int32(message.constantKind.nullValue);
        }
        if (message.constantKind?.$case === "boolValue") {
            writer.uint32(16).bool(message.constantKind.boolValue);
        }
        if (message.constantKind?.$case === "int64Value") {
            writer.uint32(24).int64(message.constantKind.int64Value);
        }
        if (message.constantKind?.$case === "uint64Value") {
            writer.uint32(32).uint64(message.constantKind.uint64Value);
        }
        if (message.constantKind?.$case === "doubleValue") {
            writer.uint32(41).double(message.constantKind.doubleValue);
        }
        if (message.constantKind?.$case === "stringValue") {
            writer.uint32(50).string(message.constantKind.stringValue);
        }
        if (message.constantKind?.$case === "bytesValue") {
            writer.uint32(58).bytes(message.constantKind.bytesValue);
        }
        if (message.constantKind?.$case === "durationValue") {
            duration_1.Duration.encode(message.constantKind.durationValue, writer.uint32(66).fork()).ldelim();
        }
        if (message.constantKind?.$case === "timestampValue") {
            timestamp_1.Timestamp.encode(toTimestamp(message.constantKind.timestampValue), writer.uint32(74).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseConstant();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.constantKind = {
                        $case: "nullValue",
                        nullValue: reader.int32(),
                    };
                    break;
                case 2:
                    message.constantKind = {
                        $case: "boolValue",
                        boolValue: reader.bool(),
                    };
                    break;
                case 3:
                    message.constantKind = {
                        $case: "int64Value",
                        int64Value: longToNumber(reader.int64()),
                    };
                    break;
                case 4:
                    message.constantKind = {
                        $case: "uint64Value",
                        uint64Value: longToNumber(reader.uint64()),
                    };
                    break;
                case 5:
                    message.constantKind = {
                        $case: "doubleValue",
                        doubleValue: reader.double(),
                    };
                    break;
                case 6:
                    message.constantKind = {
                        $case: "stringValue",
                        stringValue: reader.string(),
                    };
                    break;
                case 7:
                    message.constantKind = {
                        $case: "bytesValue",
                        bytesValue: reader.bytes(),
                    };
                    break;
                case 8:
                    message.constantKind = {
                        $case: "durationValue",
                        durationValue: duration_1.Duration.decode(reader, reader.uint32()),
                    };
                    break;
                case 9:
                    message.constantKind = {
                        $case: "timestampValue",
                        timestampValue: fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32())),
                    };
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSourceInfo() {
    return {
        syntaxVersion: "",
        location: "",
        lineOffsets: [],
        positions: {},
        macroCalls: {},
    };
}
exports.SourceInfo = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.syntaxVersion !== "") {
            writer.uint32(10).string(message.syntaxVersion);
        }
        if (message.location !== "") {
            writer.uint32(18).string(message.location);
        }
        writer.uint32(26).fork();
        for (const v of message.lineOffsets) {
            writer.int32(v);
        }
        writer.ldelim();
        Object.entries(message.positions).forEach(([key, value]) => {
            exports.SourceInfo_PositionsEntry.encode({ key: key, value }, writer.uint32(34).fork()).ldelim();
        });
        Object.entries(message.macroCalls).forEach(([key, value]) => {
            exports.SourceInfo_MacroCallsEntry.encode({ key: key, value }, writer.uint32(42).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSourceInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.syntaxVersion = reader.string();
                    break;
                case 2:
                    message.location = reader.string();
                    break;
                case 3:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.lineOffsets.push(reader.int32());
                        }
                    }
                    else {
                        message.lineOffsets.push(reader.int32());
                    }
                    break;
                case 4:
                    const entry4 = exports.SourceInfo_PositionsEntry.decode(reader, reader.uint32());
                    if (entry4.value !== undefined) {
                        message.positions[entry4.key] = entry4.value;
                    }
                    break;
                case 5:
                    const entry5 = exports.SourceInfo_MacroCallsEntry.decode(reader, reader.uint32());
                    if (entry5.value !== undefined) {
                        message.macroCalls[entry5.key] = entry5.value;
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSourceInfo_PositionsEntry() {
    return { key: 0, value: 0 };
}
exports.SourceInfo_PositionsEntry = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== 0) {
            writer.uint32(8).int64(message.key);
        }
        if (message.value !== 0) {
            writer.uint32(16).int32(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSourceInfo_PositionsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = longToNumber(reader.int64());
                    break;
                case 2:
                    message.value = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSourceInfo_MacroCallsEntry() {
    return { key: 0, value: undefined };
}
exports.SourceInfo_MacroCallsEntry = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== 0) {
            writer.uint32(8).int64(message.key);
        }
        if (message.value !== undefined) {
            exports.Expr.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSourceInfo_MacroCallsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = longToNumber(reader.int64());
                    break;
                case 2:
                    message.value = exports.Expr.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
function createBaseSourcePosition() {
    return { location: "", offset: 0, line: 0, column: 0 };
}
exports.SourcePosition = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.location !== "") {
            writer.uint32(10).string(message.location);
        }
        if (message.offset !== 0) {
            writer.uint32(16).int32(message.offset);
        }
        if (message.line !== 0) {
            writer.uint32(24).int32(message.line);
        }
        if (message.column !== 0) {
            writer.uint32(32).int32(message.column);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSourcePosition();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.location = reader.string();
                    break;
                case 2:
                    message.offset = reader.int32();
                    break;
                case 3:
                    message.line = reader.int32();
                    break;
                case 4:
                    message.column = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
var globalThis = (() => {
    if (typeof globalThis !== "undefined")
        return globalThis;
    if (typeof self !== "undefined")
        return self;
    if (typeof window !== "undefined")
        return window;
    if (typeof global !== "undefined")
        return global;
    throw "Unable to locate global object";
})();
function toTimestamp(date) {
    const seconds = date.getTime() / 1000;
    const nanos = (date.getTime() % 1000) * 1000000;
    return { seconds, nanos };
}
function fromTimestamp(t) {
    let millis = t.seconds * 1000;
    millis += t.nanos / 1000000;
    return new Date(millis);
}
function longToNumber(long) {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (_m0.util.Long !== long_1.default) {
    _m0.util.Long = long_1.default;
    _m0.configure();
}
//# sourceMappingURL=syntax.js.map